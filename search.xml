<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>c++文件和流</title>
      <link href="/%E7%BC%96%E7%A8%8B%E7%B1%BB/c-%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/"/>
      <url>/%E7%BC%96%E7%A8%8B%E7%B1%BB/c-%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="C-文件和流"><a href="#C-文件和流" class="headerlink" title="C++文件和流"></a>C++文件和流</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">数据类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">ofstream</td><td align="left">该数据类型表示输出文件流，用于创建文件并向文件写入信息。</td></tr><tr><td align="left">ifstream</td><td align="left">该数据类型表示输入文件流，用于从文件读取信息。</td></tr><tr><td align="left">fstream</td><td align="left">该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, ios::openmode mode)</span></span>;</span><br></pre></td></tr></table></figure><p>openmode</p><table><thead><tr><th align="left">模式标志</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">ios::app</td><td align="left">追加模式。所有写入都追加到文件末尾。</td></tr><tr><td align="left">ios::ate</td><td align="left">文件打开后定位到文件末尾。</td></tr><tr><td align="left">ios::in</td><td align="left">打开文件用于读取。</td></tr><tr><td align="left">ios::out</td><td align="left">打开文件用于写入。</td></tr><tr><td align="left">ios::trunc</td><td align="left">如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ofstream outfile;</span><br><span class="line">outfile.<span class="built_in">open</span>(<span class="string">&quot;file.dat&quot;</span>, ios::out | ios::trunc );</span><br></pre></td></tr></table></figure><p>以写入模式打开文件，并希望截断文件，以防文件已存在</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifstream  afile;</span><br><span class="line">afile.<span class="built_in">open</span>(<span class="string">&quot;file.dat&quot;</span>, ios::out | ios::in );</span><br></pre></td></tr></table></figure><p>打开一个文件用于读写</p><p>文件使用结束应该手动close()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* path = <span class="string">&quot;D:\\syq-repos\\abc.txt&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* path2 = <span class="string">&quot;D:\\syq-repos\\abcttt.txt&quot;</span>;</span><br><span class="line"><span class="function">std::ifstream <span class="title">file</span><span class="params">(path)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">std::ofstream <span class="title">file2</span><span class="params">(path2,std::ios::out | std::ios::trunc)</span></span>;</span><br><span class="line">std::stringstream ssTmpFileContent;</span><br><span class="line"><span class="keyword">while</span> (!file.<span class="built_in">eof</span>())</span><br><span class="line">&#123;</span><br><span class="line">    std::string sWord;</span><br><span class="line">    file &gt;&gt; sWord;</span><br><span class="line">    file2 &lt;&lt; sWord;</span><br><span class="line">    ssTmpFileContent &lt;&lt; sWord;</span><br><span class="line">&#125;</span><br><span class="line">file2.<span class="built_in">close</span>();</span><br><span class="line">file.<span class="built_in">close</span>();</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">![结果](fstream<span class="number">-1.</span>png)</span><br><span class="line"></span><br><span class="line">转换后空格和换行都没有了，因为ifstream通过 &gt;&gt; 从文件读取数据时会在**空格或者换行**的地方隔断</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line"><span class="keyword">char</span> data[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> nSize = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">while</span> (nSize = file.<span class="built_in">read</span>(data, <span class="number">1024</span>).<span class="built_in">gcount</span>())</span><br><span class="line">&#123;       </span><br><span class="line">    file2.<span class="built_in">write</span>(data, nSize);</span><br><span class="line">    <span class="comment">//file2 &lt;&lt; data;</span></span><br><span class="line">    ssTmpFileContent &lt;&lt; data;</span><br><span class="line">&#125;</span><br><span class="line">file2.<span class="built_in">write</span>(data, nSize);</span><br><span class="line">file2.<span class="built_in">close</span>();</span><br><span class="line">file.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure><p><img src="/%E7%BC%96%E7%A8%8B%E7%B1%BB/c-%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/fstream-2.png" alt="结果"></p><p>用read的方式可以把所有的字符都读取出来</p><h2 id="输入输出流"><a href="#输入输出流" class="headerlink" title="输入输出流"></a>输入输出流</h2><h3 id="标准-I-O"><a href="#标准-I-O" class="headerlink" title="标准 I/O"></a>标准 I/O</h3><table><thead><tr><th align="left">对象</th><th align="left">描述</th><th align="left">支持重定向</th></tr></thead><tbody><tr><td align="left">cin</td><td align="left">cin 接收从键盘输入的数据</td><td align="left">是</td></tr><tr><td align="left">cout</td><td align="left">cout 向屏幕上输出数据</td><td align="left">是</td></tr><tr><td align="left">cerr</td><td align="left">输出警告和错误信息给程序的使用者</td><td align="left">否</td></tr><tr><td align="left">clog</td><td align="left">输出程序执行过程中的日志信息(不公开)</td><td align="left">否</td></tr></tbody></table><p><em><strong>cin 输入流对象常用成员方法</strong></em></p><table><thead><tr><th align="left">成员方法名</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">getline(str,n,ch)</td><td align="left">从输入流中接收 n-1 个字符给 str 变量，当遇到指定 ch 字符时会停止读 取，默认情况下 ch 为 ‘\0’。</td></tr><tr><td align="left">get()</td><td align="left">从输入流中读取一个字符，同时该字符会从输入流中消失。</td></tr><tr><td align="left">gcount()</td><td align="left">返回上次从输入流提取出的字符个数，该函数常和 get()、getline()、ignore()、peek()、read()、readsome()、putback() 和 unget() 联用。</td></tr><tr><td align="left">peek()</td><td align="left">返回输入流中的第一个字符，但并不是提取该字符。</td></tr><tr><td align="left">putback(c)</td><td align="left">将字符 c 置入输入流（缓冲区）。</td></tr><tr><td align="left">ignore(n,ch)</td><td align="left">从输入流中逐个提取字符，但提取出的字符被忽略，不被使用，直至提取出 n 个字 符，或者当前读取的字符为 ch。</td></tr><tr><td align="left">operator&gt;&gt;</td><td align="left">重载 &gt;&gt; 运算符，用于读取指定类型的数据，并返回输入流对象本身。</td></tr></tbody></table><p><em><strong>cout 输出流对象常用成员方法</strong></em></p><h3 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>在默认情况下，cin 只能接收从键盘输入的数据，cout 也只能将数据输出到屏幕上。但通过重定向，cin 可以将指定文件作为输入源，即接收文件中早已准备好的数据，同样 cout 可以将原本要输出到屏幕上的数据转而写到指定文件中。</p><h4 id="freopen-函数实现重定向"><a href="#freopen-函数实现重定向" class="headerlink" title="freopen()函数实现重定向"></a>freopen()函数实现重定向</h4><p>头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>  <span class="comment">//freopen_s</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* path = <span class="string">&quot;D:\\syq-repos\\abc.txt&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* path2 = <span class="string">&quot;D:\\syq-repos\\abcttt.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">std::string str;</span><br><span class="line"><span class="keyword">typedef</span> FILE* FP;</span><br><span class="line">FP f1;</span><br><span class="line">FP f2;</span><br><span class="line"><span class="keyword">errno_t</span> err1 = <span class="built_in">freopen_s</span>(&amp;f1,path,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line"><span class="keyword">errno_t</span> err2 = <span class="built_in">freopen_s</span>(&amp;f2, path2, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (std::cin &gt;&gt; str)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (f1 != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fclose</span>(f1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (f2 != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fclose</span>(f2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="rdbuf-函数实现重定向"><a href="#rdbuf-函数实现重定向" class="headerlink" title="rdbuf()函数实现重定向"></a>rdbuf()函数实现重定向</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* path = <span class="string">&quot;D:\\syq-repos\\abc.txt&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* path2 = <span class="string">&quot;D:\\syq-repos\\abcttt.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">std::string str;</span><br><span class="line"></span><br><span class="line"><span class="function">std::ifstream <span class="title">fin</span><span class="params">(path)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> bufOld = std::cin.<span class="built_in">rdbuf</span>(fin.<span class="built_in">rdbuf</span>());</span><br><span class="line"><span class="function">std::ofstream <span class="title">fout</span><span class="params">(path2,std::ios::out| std::ios::trunc)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> bufOld2 = std::cout.<span class="built_in">rdbuf</span>(fout.<span class="built_in">rdbuf</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (std::cin &gt;&gt; str)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::cin.<span class="built_in">rdbuf</span>(bufOld);</span><br><span class="line">std::cout.<span class="built_in">rdbuf</span>(bufOld2);</span><br><span class="line">fin.<span class="built_in">close</span>();</span><br><span class="line">fout.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure><h4 id="通过控制台实现重定向"><a href="#通过控制台实现重定向" class="headerlink" title="通过控制台实现重定向"></a>通过控制台实现重定向</h4><blockquote><p>C:\Users\mengma&gt;D:\demo.exe &lt;in.txt &gt;out.txt</p></blockquote><p>执行后会发现，控制台没有任何输出。这是因为，我们使用了”&lt;in.txt”对程序中的 cin 输入流做了重定向，同时还用 “&gt;out.txt”对程序中的 cout 输出流做了重定向。</p><p>如果此时读者进入 C:\Users\mengma 目录就会发现，当前目录生成了一个 out.txt 文件，其中就存储了 demo.ext 的执行结果。</p><blockquote><p>在控制台中使用 &gt; 或者 &lt; 实现重定向的方式，DOS、windows、Linux 以及 UNIX 都自动识别。</p></blockquote><h3 id="tellp-和seekp"><a href="#tellp-和seekp" class="headerlink" title="tellp()和seekp()"></a>tellp()和seekp()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">streampos <span class="title">tellp</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>tellp() 不需要传递任何参数，会返回一个 streampos 类型值。事实上，streampos 是 fpos 类型的别名，而 fpos 通过自动类型转换，可以直接赋值给一个整形变量（即 short、int 和 long）。也就是说，在使用此函数时，我们可以用一个整形变量来接收该函数的返回值。</p><blockquote><p>注意，当输出流缓冲区中没有任何数据时，该函数返回的整形值为 0；当指定的输出流缓冲区不支持此操作，或者操作失败时，该函数返回的整形值为 -1。</p></blockquote><p>seekp() 方法用于指定下一个进入输出缓冲区的字符所在的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定下一个字符存储的位置</span></span><br><span class="line"><span class="function">ostream&amp; <span class="title">seekp</span> <span class="params">(streampos pos)</span></span>;</span><br><span class="line"><span class="comment">//通过偏移量间接指定下一个字符的存储位置   </span></span><br><span class="line"><span class="function">ostream&amp; <span class="title">seekp</span> <span class="params">(streamoff off, ios_base::seekdir way)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，各个参数的含义如下：</p><ul><li><p>pos：用于接收一个正整数；</p></li><li><p>off：用于指定相对于 way 位置的偏移量，其本质也是接收一个整数，可以是正数（代表正偏移）或者负数（代表负偏移）；</p></li><li><p>way：用于指定偏移位置，即从哪里计算偏移量，它可以接收表 1 所示的 3 个值。</p></li></ul><table><thead><tr><th align="left">模式标志</th><th align="left">描 述</th></tr></thead><tbody><tr><td align="left">ios::beg</td><td align="left">从文件头开始计算偏移量</td></tr><tr><td align="left">ios::end</td><td align="left">从文件末尾开始计算偏移量</td></tr><tr><td align="left">ios::cur</td><td align="left">从当前位置开始计算偏移量</td></tr></tbody></table><p>seekp() 方法会返回一个引用形式的 ostream 类对象</p><h3 id="cout成员方法格式化输出"><a href="#cout成员方法格式化输出" class="headerlink" title="cout成员方法格式化输出"></a>cout成员方法格式化输出</h3><table><thead><tr><th align="left">成员函数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">flags(fmtfl)</td><td align="left">当前格式状态全部替换为 fmtfl。注意，fmtfl 可以表示一种格式，也可以表示多种格式。</td></tr><tr><td align="left">precision(n)</td><td align="left">设置输出浮点数的精度为 n。</td></tr><tr><td align="left">width(w)</td><td align="left">指定输出宽度为 w 个字符。</td></tr><tr><td align="left">fill(c)</td><td align="left">在指定输出宽度的情况下，输出的宽度不足时用字符 c 填充（默认情况是用空格填充）。</td></tr><tr><td align="left">setf(fmtfl, mask)</td><td align="left">在当前格式的基础上，追加 fmtfl 格式，并删除 mask 格式。其中，mask 参数可以省略。</td></tr><tr><td align="left">unsetf(mask)</td><td align="left">在当前格式的基础上，删除 mask 格式。</td></tr></tbody></table><table><thead><tr><th align="left">标 志</th><th align="left">作 用</th></tr></thead><tbody><tr><td align="left">ios::boolapha</td><td align="left">把 true 和 false 输出为字符串</td></tr><tr><td align="left">ios::left</td><td align="left">输出数据在本域宽范围内向左对齐</td></tr><tr><td align="left">ios::right</td><td align="left">输出数据在本域宽范围内向右对齐</td></tr><tr><td align="left">ios::internal</td><td align="left">数值的符号位在域宽内左对齐，数值右对齐，中间由填充字符填充</td></tr><tr><td align="left">ios::dec</td><td align="left">设置整数的基数为 10</td></tr><tr><td align="left">ios::oct</td><td align="left">设置整数的基数为 8</td></tr><tr><td align="left">ios::hex</td><td align="left">设置整数的基数为 16</td></tr><tr><td align="left">ios::showbase</td><td align="left">强制输出整数的基数（八进制数以 0 开头，十六进制数以 0x 打头）</td></tr><tr><td align="left">ios::showpoint</td><td align="left">强制输出浮点数的小点和尾数 0</td></tr><tr><td align="left">ios::uppercase</td><td align="left">在以科学记数法格式 E 和以十六进制输出字母时以大写表示</td></tr><tr><td align="left">ios::showpos</td><td align="left">对正数显示“+”号</td></tr><tr><td align="left">ios::scientific</td><td align="left">浮点数以科学记数法格式输出</td></tr><tr><td align="left">ios::fixed</td><td align="left">浮点数以定点格式（小数形式）输出</td></tr><tr><td align="left">ios::unitbuf</td><td align="left">每次输出之后刷新所有的流</td></tr></tbody></table><p>值得一提的是，当调用 unsetf() 或者 2 个参数的 setf() 函数时，为了提高编写代码的效率，可以给 mask 参数传递如下 3 个组合格式：</p><ul><li>ios::adjustfield：等价于 ios::left | ios::right | ios::internal；</li><li>ios::basefield：等价于 ios::dec | ios::oct | ios::hex；</li><li>ios::floatfield：等价于 ios::scientific | ios::fixed。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> f = <span class="number">123</span>;</span><br><span class="line"><span class="comment">//设定后续以科学计数法表示浮点数</span></span><br><span class="line">cout.<span class="built_in">setf</span>(ios::scientific);</span><br><span class="line">cout &lt;&lt; f &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="comment">//删除之前有关浮点表示的设定</span></span><br><span class="line">cout.<span class="built_in">unsetf</span>(ios::floatfield);</span><br><span class="line">cout &lt;&lt; f;</span><br></pre></td></tr></table></figure><h3 id="使用流操纵算子格式化输出"><a href="#使用流操纵算子格式化输出" class="headerlink" title="使用流操纵算子格式化输出"></a>使用流操纵算子格式化输出</h3><p>iomanip 头文件中定义的一些常用的格式控制符，它们都可用于格式化输出。</p><p>流操纵算子|作  用<br>| :— | :— |<br>*dec|以十进制形式输出整数|常用<br>hex|以十六进制形式输出整数|<br>oct|以八进制形式输出整数|<br>fixed|以普通小数形式输出浮点数|<br>scientific|以科学计数法形式输出浮点数|<br>left|左对齐，即在宽度不足时将填充字符添加到右边|<br>*right|右对齐，即在宽度不足时将填充字符添加到左边|<br>setbase(b)|设置输出整数时的进制，b=8、10 或 16|<br>setw(w)|指定输出宽度为 w 个字符，或输入字符串时读入 w 个字符。注意，该函数所起的作用是一次性的，即只影响下一次 cout 输出。<br>setfill(c)|在指定输出宽度的情况下，输出的宽度不足时用字符 c 填充（默认情况是用空格填充）<br>setprecision(n)|设置输出浮点数的精度为 n。<br>在使用非 fixed 且非 scientific 方式输出的情况下，n 即为有效数字最多的位数，如果有效数字位数超过 n，则小数部分四舍五人，或自动变为科学计 数法输出并保留一共 n 位有效数字。<br>在使用 fixed 方式和 scientific 方式输出的情况下，n 是小数点后面应保留的位数。<br>setiosflags(mask)|在当前格式状态下，追加 mask 格式，mask 参数可选择表 2 中的所有值。<br>resetiosflags(mask)|在当前格式状态下，删除 mask 格式，mask 参数可选择表 2 中的所有值。<br>boolapha|把 true 和 false 输出为字符串|不常用<br>*noboolalpha|把 true 和 false 输出为 0、1<br>showbase|输出表示数值的进制的前缀<br>*noshowbase|不输出表示数值的进制.的前缀<br>showpoint|总是输出小数点<br>*noshowpoint|只有当小数部分存在时才显示小数点<br>showpos|在非负数值中显示 +<br>*noshowpos|在非负数值中不显示 +<br>uppercase|十六进制数中使用 A<del>E。若输出前缀，则前缀输出 0X，科学计数法中输出 E<br>*nouppercase|十六进制数中使用 a</del>e。若输出前缀，则前缀输出 0x，科学计数法中输出 e。<br>internal|数值的符号（正负号）在指定宽度内左对齐，数值右对 齐，中间由填充字符填充。</p><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//以十六进制输出整数</span></span><br><span class="line">cout &lt;&lt; hex &lt;&lt; <span class="number">16</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//删除之前设定的进制格式，以默认的 10 进制输出整数</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">resetiosflags</span>(ios::basefield)&lt;&lt; <span class="number">16</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">double</span> a = <span class="number">123</span>;</span><br><span class="line"><span class="comment">//以科学计数法的方式输出浮点数</span></span><br><span class="line">cout &lt;&lt; scientific &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"><span class="comment">//删除之前设定的科学计数法的方法</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">resetiosflags</span>(ios::scientific) &lt;&lt; a &lt;&lt; endl;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tensorflow practice (win10)</title>
      <link href="/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/tensorflow-practice-win10/"/>
      <url>/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/tensorflow-practice-win10/</url>
      
        <content type="html"><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h1 id="安装cpu版本的tensorflow"><a href="#安装cpu版本的tensorflow" class="headerlink" title="安装cpu版本的tensorflow"></a>安装cpu版本的tensorflow</h1><blockquote><p>安装配置官网讲的很详细，可以自行查看<a href="https://tensorflow.google.cn/install/source_windows">windows下构建tensorflow</a></p></blockquote><blockquote><p>或者参考github上的install guide:</p></blockquote><p>To install the current release, which includes support for CUDA-enabled GPU cards (Ubuntu and Windows):</p><pre><code>$ pip install tensorflow</code></pre><p>A smaller CPU-only package is also available:</p><pre><code>$ pip install tensorflow-cpu</code></pre><h1 id="test"><a href="#test" class="headerlink" title="test"></a>test</h1><pre><code>$ python&gt;&gt;&gt; import tensorflow as tf&gt;&gt;&gt; tf.add(1, 2).numpy()3&gt;&gt;&gt; hello = tf.constant(&#39;Hello, TensorFlow!&#39;)&gt;&gt;&gt; hello.numpy()b&#39;Hello, TensorFlow!&#39;</code></pre><hr><blockquote><p>自己搭建环境可能会有各种问题，建议直接在anaconda上新建一个tensorflow的环境使用。</p></blockquote><blockquote><p>环境搭建好了之后，就可以根据官网上面的详细<a href="https://tensorflow.google.cn/tutorials/quickstart/beginner?hl=zh_cn">教程</a>，一步步进行学习了</p></blockquote><p><img src="/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/tensorflow-practice-win10/start-practice.png"></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> tensorflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pyinstall打包方案</title>
      <link href="/%E7%BC%96%E7%A8%8B%E7%B1%BB/pyinstall%E6%89%93%E5%8C%85%E6%96%B9%E6%A1%88/"/>
      <url>/%E7%BC%96%E7%A8%8B%E7%B1%BB/pyinstall%E6%89%93%E5%8C%85%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h2 id="pyinstall打包方案"><a href="#pyinstall打包方案" class="headerlink" title="pyinstall打包方案"></a>pyinstall打包方案</h2><h3 id="简单打包"><a href="#简单打包" class="headerlink" title="简单打包"></a>简单打包</h3><p>安装pyinstaller</p><pre><code>pip install pyinstaller</code></pre><p>切到需要打包的文件<code>Target.py</code>目录下，运行</p><pre><code>pyinstaller [&lt;args&gt;] Target.py</code></pre><p>常用参数用法：</p><pre><code>--distpath &lt;path&gt;: 打包到哪个目录下-w: 指定生成 GUI 软件，也就是运行时不打开控制台-c: 运行时打开控制台-i &lt;Icon File&gt;: 指定打包后可执行文件的图标--clean: 在构建之前清理PyInstaller缓存并删除临时文件</code></pre><p>打包类型分为单个文件和文件夹：</p><pre><code>-D: 创建包含可执行文件的单文件夹包，同时会有一大堆依赖的 dll 文件，这是默认选项-F: 只生成一个 .exe 文件，如果项目比较小的话可以用这个，但比较大的话就不推荐</code></pre><p>运行时可能报文件丢失的错误，因为打包的时候配置文件之类的并不会一并打包过去，我们手动复制进打包目录下就行。</p><h3 id="文件过大问题"><a href="#文件过大问题" class="headerlink" title="文件过大问题"></a>文件过大问题</h3><p>如果是在Anacanda的环境下进行打包，会把很多不相干的库也打包进来，造成文件变得很大，随随便便就是几百兆，因此，我们需要用纯净的环境进行打包，来减少那些不相干的东西。</p><p>Pipenv 是一款管理虚拟环境的命令行软件，简单来讲，它可以创建一个只在某个目录下的局部 Python 环境，而这个环境是可以和全局环境脱离开的。</p><p>首先，安装pipenv</p><pre><code>pip install pipenv</code></pre><p>运行</p><pre><code>pipenv install [--python 3.9.7]</code></pre><p>install后面的参数可以缺省或者指定你安装的python版本</p><p><img src="/%E7%BC%96%E7%A8%8B%E7%B1%BB/pyinstall%E6%89%93%E5%8C%85%E6%96%B9%E6%A1%88/pipenv_install.png" alt="install"></p><p>这样虚拟环境就创建成功了，使用命令<code>pip list</code>可以发现里面只有很少的库。</p><p>在虚拟环境下安装pyinstaller和依赖库：</p><pre><code>pipenv install pyinstallerpipenv install [libname]</code></pre><p>安装完成后先运行一下，如果没问题，再进行打包。</p><p>打包完毕后，发现，文件少了很多，从几百兆减少到几十兆，这样我们就打包完成了。</p><h2 id="其它注意事项"><a href="#其它注意事项" class="headerlink" title="其它注意事项"></a>其它注意事项</h2><p>打包过程中可能会遇到没有upx的问题，可以再github上面下载下来,复制upx.exe放到pyinstaller.exe对应的文件目录下。</p>]]></content>
      
      
      <categories>
          
          <category> 编程类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python删除目录下所有文件的方法</title>
      <link href="/%E7%BC%96%E7%A8%8B%E7%B1%BB/python%E5%88%A0%E9%99%A4%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/%E7%BC%96%E7%A8%8B%E7%B1%BB/python%E5%88%A0%E9%99%A4%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="删除所有文件及文件夹"><a href="#删除所有文件及文件夹" class="headerlink" title="删除所有文件及文件夹"></a>删除所有文件及文件夹</h2><p>python中没有专门用于删除文件的接口，不过实现起来也不难，我这里提供了一种一种递归的方式，先利用os.listdir(path)获取目录下的所有文件，如果是文件夹就进行递归，直到最后一级；如果是文件，修改只读为可读写，删除文件。最后利用shutil.rmtree(path)删除所有目录。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> stat</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delFiles</span>(<span class="params">path</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        lstFiles = os.listdir(path)    </span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> lstFiles:</span><br><span class="line">            full_path = os.path.join(path,file)</span><br><span class="line">            <span class="keyword">if</span> os.path.isdir(full_path):</span><br><span class="line">                delFiles(full_path)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                os.chmod(full_path,stat.S_IWRITE|stat.S_IWGRP|stat.S_IWOTH)</span><br><span class="line">                os.remove(full_path)</span><br><span class="line">        <span class="keyword">if</span> os.path.exists(path):</span><br><span class="line">            shutil.rmtree(path)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">        <span class="built_in">print</span>(err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cxx并发之condition_variable</title>
      <link href="/%E7%BC%96%E7%A8%8B%E7%B1%BB/cxx%E5%B9%B6%E5%8F%91%E4%B9%8Bcondition-variable/"/>
      <url>/%E7%BC%96%E7%A8%8B%E7%B1%BB/cxx%E5%B9%B6%E5%8F%91%E4%B9%8Bcondition-variable/</url>
      
        <content type="html"><![CDATA[<h2 id="condition-variable"><a href="#condition-variable" class="headerlink" title="condition_variable"></a>condition_variable</h2><p><a href="http://www.cplusplus.com/reference/condition_variable/">参考</a></p><p>条件变量是一种能够阻塞调用线程的对象，直到通知恢复为止。</p><p>当调用它的一个等待函数时，它使用unique_lock(通过互斥锁mutex)来锁定线程。线程保持阻塞状态，直到被另一个线程唤醒，该线程调用同一个condition_variable对象上的通知函数。</p><p>类型为condition_variable的对象总是使用unique_lock&lt;mutex&gt;来等待;对于适用于任何类型的可锁定类型的替代方法，请参阅condition_variable_any。</p><p>三个wait functions，</p><table><thead><tr><th align="left"></th><th></th></tr></thead><tbody><tr><td align="left">wait</td><td>Wait until notified</td></tr><tr><td align="left">wait_for</td><td>Wait for timeout or until notified</td></tr><tr><td align="left">wait_until</td><td>Wait until notified or time point</td></tr></tbody></table><p>两个notify functions,</p><table><thead><tr><th align="left"></th><th align="left"></th></tr></thead><tbody><tr><td align="left">notify_one</td><td align="left">Notify one</td></tr><tr><td align="left">notify_all</td><td align="left">Notify all</td></tr></tbody></table><h3 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fff</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">      &#123;</span><br><span class="line">          cout &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">startProcess</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      mutex mu;</span><br><span class="line">      condition_variable cdv;</span><br><span class="line">      <span class="keyword">bool</span> bLock = <span class="literal">false</span>;</span><br><span class="line">      <span class="function">thread <span class="title">th1</span><span class="params">([&amp;]</span></span></span><br><span class="line"><span class="params"><span class="function">          &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="keyword">for</span> (;;)</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                  &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                      std::unique_lock&lt;std::mutex&gt; lock(mu);</span></span></span><br><span class="line"><span class="params"><span class="function">                      cdv.wait(lock,</span></span></span><br><span class="line"><span class="params"><span class="function">                          [&amp;bLock] &#123; <span class="keyword">return</span> bLock; &#125;);</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">                      bLock = <span class="literal">false</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">                  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">                  fff();</span></span></span><br><span class="line"><span class="params"><span class="function">              &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">              </span></span></span><br><span class="line"><span class="params"><span class="function">          &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">      )</span></span>;</span><br><span class="line"></span><br><span class="line">      <span class="function">thread <span class="title">th2</span><span class="params">([&amp;]</span></span></span><br><span class="line"><span class="params"><span class="function">          &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="keyword">for</span> (;;)</span></span></span><br><span class="line"><span class="params"><span class="function">              &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                  &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                      std::unique_lock&lt;std::mutex&gt; lock(mu);</span></span></span><br><span class="line"><span class="params"><span class="function">                      cdv.wait(lock,</span></span></span><br><span class="line"><span class="params"><span class="function">                          [&amp;bLock] &#123; <span class="keyword">return</span> bLock; &#125;);</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">                      bLock = <span class="literal">false</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">                  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">                  fff();</span></span></span><br><span class="line"><span class="params"><span class="function">              &#125;        </span></span></span><br><span class="line"><span class="params"><span class="function">          &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">      )</span></span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(;;)</span><br><span class="line">      &#123;</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mu)</span></span>;</span><br><span class="line">              bLock = <span class="literal">true</span>;              </span><br><span class="line">          &#125; </span><br><span class="line">          <span class="built_in">Sleep</span>(<span class="number">5000</span>);</span><br><span class="line">          cdv.<span class="built_in">notify_one</span>();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="wait-for"><a href="#wait-for" class="headerlink" title="wait_for"></a>wait_for</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (cdv.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>)) == std::cv_status::timeout) &#123;</span><br><span class="line">      std::cout &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt;<span class="string">&#x27;.&#x27;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="wait-until"><a href="#wait-until" class="headerlink" title="wait until"></a>wait until</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xtime t;</span><br><span class="line">t.sec = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (cdv.<span class="built_in">wait_until</span>(lock, &amp;t) == std::cv_status::timeout) &#123;</span><br><span class="line">      std::cout &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&#x27;.&#x27;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++并发之&lt;future&gt;</title>
      <link href="/%E7%BC%96%E7%A8%8B%E7%B1%BB/c-%E5%B9%B6%E5%8F%91%E4%B9%8B-future/"/>
      <url>/%E7%BC%96%E7%A8%8B%E7%B1%BB/c-%E5%B9%B6%E5%8F%91%E4%B9%8B-future/</url>
      
        <content type="html"><![CDATA[<h2 id="future"><a href="#future" class="headerlink" title="future"></a>future</h2><p>std::future 可以用来获取异步任务的结果，因此可以把它当成一种简单的线程间同步的手段。std::future 通常由某个 Provider 创建，你可以把 Provider 想象成一个异步任务的提供者，Provider 在某个线程中设置共享状态的值，与该共享状态相关联的 std::future 对象调用 get（通常在另外一个线程中） 获取该值，如果共享状态的标志不为 ready，则调用 std::future::get 会阻塞当前的调用者，直到 Provider 设置了共享状态的值（此时共享状态的标志变为 ready），std::future::get 返回异步任务的值或异常（如果发生了异常）。</p><p>&lt;future&gt;头文件包含以下几个类和函数：</p><ul><li>Providers类：std::promise，std::package_task</li><li>Future类：std::future，shared_future</li><li>Provides函数：std::async()</li><li>其他类型：std::future_error，std::future_errc，std::future_status，std::launch</li></ul><h3 id="std-promise"><a href="#std-promise" class="headerlink" title="std::promise"></a>std::promise</h3><p>promise 对象可以保存某一类型 T 的值，该值可被 future 对象读取（可能在另外一个线程中），因此 promise 也提供了一种线程同步的手段。在 promise 对象构造时可以和一个共享状态（通常是std::future）相关联，并可以在相关联的共享状态(std::future)上保存一个类型为 T 的值。</p><p>可以通过 get_future 来获取与该 promise 对象相关联的 future 对象，调用该函数之后，两个对象共享相同的共享状态(shared state)</p><ul><li>promise 对象是异步 Provider，它可以在某一时刻设置共享状态的值。</li><li>future 对象可以异步返回共享状态的值，或者在必要的情况下阻塞调用者并等待共享状态标志变为 ready，然后才能获取共享状态的值。</li></ul><p>另外，std::promise 的 operator= 没有拷贝语义，即 std::promise 普通的赋值操作被禁用，operator= 只有 move 语义，所以 std::promise 对象是禁止拷贝的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_input</span><span class="params">(std::promise&lt;<span class="keyword">int</span>&gt;&amp; pi)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> x;</span><br><span class="line">       std::cout &lt;&lt; <span class="string">&quot;Enter an inter va==\n&quot;</span>;</span><br><span class="line">       std::cin.<span class="built_in">exceptions</span>(std::ios::failbit);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span></span><br><span class="line">       &#123;</span><br><span class="line">           std::cin &gt;&gt; x;</span><br><span class="line">           pi.<span class="built_in">set_value</span>(x); <span class="comment">//set_value会将共享标志位置为ready</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in"><span class="keyword">catch</span></span> (std::exception&amp;)</span><br><span class="line">       &#123;</span><br><span class="line">           pi.<span class="built_in">set_exception</span>(std::<span class="built_in">current_exception</span>());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">printSth</span><span class="params">(std::future&lt;<span class="keyword">int</span>&gt;&amp; fut)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">try</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">int</span> x = fut.<span class="built_in">get</span>();<span class="comment">//在共享标志位置为ready之前会被阻塞</span></span><br><span class="line">           std::cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in"><span class="keyword">catch</span></span> (std::exception&amp; e)</span><br><span class="line">       &#123;</span><br><span class="line">           std::cout &lt;&lt; <span class="string">&quot;exception&quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">startProcess</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       std::promise&lt;<span class="keyword">int</span>&gt; pi;</span><br><span class="line">       std::future&lt;<span class="keyword">int</span>&gt; fut = pi.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">       <span class="function">std::thread <span class="title">th1</span><span class="params">(get_input, std::ref(pi))</span></span>;</span><br><span class="line">       <span class="function">std::thread <span class="title">th2</span><span class="params">(printSth, std::ref(fut))</span></span>;</span><br><span class="line"></span><br><span class="line">       th1.<span class="built_in">join</span>();</span><br><span class="line">       th2.<span class="built_in">join</span>();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>std::promise::set_value_at_thread_exit 设置共享状态的值，但是只有当线程退出的时候promise对象才会置为ready</p><h3 id="std-packaged-task"><a href="#std-packaged-task" class="headerlink" title="std::packaged_task"></a>std::packaged_task</h3><p>std::packaged_task 对象内部包含了两个最基本元素，一、被包装的任务(stored task)，任务(task)是一个可调用的对象，如函数指针、成员函数指针或者函数对象，二、共享状态(shared state)，用于保存任务的返回值，可以通过 std::future 对象来达到异步访问共享状态的效果。</p><p>可以通过 std::packged_task::get_future 来获取与共享状态相关联的 std::future 对象。在调用该函数之后，两个对象共享相同的共享状态，具体解释如下：</p><ul><li>std::packaged_task 对象是异步 Provider，它在某一时刻通过调用被包装的任务来设置共享状态的值。</li><li>std::future 对象是一个异步返回对象，通过它可以获得共享状态的值，当然在必要的时候需要等待共享状态标志变为 ready.</li></ul><p>std::packaged_task 的共享状态的生命周期一直持续到最后一个与之相关联的对象被释放或者销毁为止。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processWorks</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="keyword">int</span>)</span>&gt; <span class="title">task</span><span class="params">([](<span class="keyword">int</span> total) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; ++i)</span></span></span><br><span class="line"><span class="params"><span class="function">           &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">               Sleep(<span class="number">1000</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">               cout &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; i &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">           &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">return</span> total;</span></span></span><br><span class="line"><span class="params"><span class="function">           &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">       std::future&lt;<span class="keyword">int</span>&gt; fut = task.<span class="built_in">get_future</span>();       </span><br><span class="line">       <span class="built_in">task</span>(<span class="number">3</span>);</span><br><span class="line">       std::cout &lt;&lt; fut.<span class="built_in">get</span>() &lt;&lt; std::endl;<span class="comment">//此处会等待task执行完成，并返回结果</span></span><br><span class="line">       </span><br><span class="line">       task.<span class="built_in">reset</span>();<span class="comment">//重置 packaged_task 的共享状态 </span></span><br><span class="line">       fut = task.<span class="built_in">get_future</span>();</span><br><span class="line">       std::<span class="built_in">thread</span>(std::<span class="built_in">move</span>(task), <span class="number">5</span>).<span class="built_in">detach</span>();</span><br><span class="line">       std::cout &lt;&lt; fut.<span class="built_in">get</span>() &lt;&lt; std::endl;<span class="comment">//此处会等待task执行完成，并返回结果</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="std-async"><a href="#std-async" class="headerlink" title="std::async()"></a>std::async()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a non-optimized way of checking for prime numbers:</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Calculating. Please, wait...\n&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;x; ++i) <span class="keyword">if</span> (x%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// call is_prime(313222313) asynchronously:</span></span><br><span class="line">  std::future&lt;<span class="keyword">bool</span>&gt; fut = std::<span class="built_in">async</span> (is_prime,<span class="number">313222313</span>);</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Checking whether 313222313 is prime.\n&quot;</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> ret = fut.<span class="built_in">get</span>();      <span class="comment">// waits for is_prime to return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ret) std::cout &lt;&lt; <span class="string">&quot;It is prime!\n&quot;</span>;</span><br><span class="line">  <span class="keyword">else</span> std::cout &lt;&lt; <span class="string">&quot;It is not prime.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Exception-safety"><a href="#Exception-safety" class="headerlink" title="Exception safety"></a>Exception safety</h4><table><thead><tr><th align="left">exception type</th><th align="left">error condition</th><th align="left">description</th></tr></thead><tbody><tr><td align="left">system_error</td><td align="left">errc::resource_unavailable_try_again</td><td align="left">The system isunable to start a new thread</td></tr></tbody></table><h3 id="shared-future"><a href="#shared-future" class="headerlink" title="shared_future"></a>shared_future</h3><p>shared_future对象的行为类似于future对象，不同之处在于它可以被复制，并且多个shared_future对象可以共享其共享状态的所有权。它们还允许在准备就绪后多次检索处于共享状态的值。</p><p>Shared_future对象可以从future对象隐式转换(参见其构造函数)，也可以通过调用future::share显式获取。在这两种情况下，获取它的future对象将其与共享状态的关联转移到shared_future，并使其自身失效。</p><p>共享状态的生存期至少持续到与之关联的最后一个对象被销毁为止。从shared_future(使用成员get)中检索值不会释放其对共享状态的所有权(与futures不同)。因此，如果与shared_future对象关联，共享状态可以在最初获取它的对象中保存(如果有的话)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shareWorks</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       std::future&lt;<span class="keyword">int</span>&gt; fut = <span class="built_in">async</span>([] &#123;</span><br><span class="line">           cout &lt;&lt; <span class="string">&quot;async\n&quot;</span>;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">           &#125;);</span><br><span class="line">       std::shared_future&lt;<span class="keyword">int</span>&gt; sFut = fut.<span class="built_in">share</span>();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 共享的 future 对象可以被多次访问.</span></span><br><span class="line">       std::cout &lt;&lt; sFut.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">       std::cout &lt;&lt; sFut.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程间通信</title>
      <link href="/%E7%BC%96%E7%A8%8B%E7%B1%BB/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
      <url>/%E7%BC%96%E7%A8%8B%E7%B1%BB/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>进程是需要频繁的和其他进程进行交流的。例如，在一个 shell 管道中，第一个进程的输出必须传递给第二个进程，这样沿着管道进行下去。因此，进程之间如果需要通信的话，必须要使用一种良好的数据结构以至于不能被中断。下面我们会一起讨论有关 进程间通信(Inter Process Communication, IPC) 的问题。</p><p>关于进程间的通信，这里有三个问题</p><ul><li>上面提到了第一个问题，那就是一个进程如何传递消息给其他进程。</li><li>第二个问题是如何确保两个或多个线程之间不会相互干扰。例如，两个航空公司都试图为不同的顾客抢购飞机上的最后一个座位。</li><li>第三个问题是数据的先后顺序的问题，如果进程 A 产生数据并且进程 B 打印数据。则进程 B 打印数据之前需要先等 A 产生数据后才能够进行打印。</li></ul><p>需要注意的是，这三个问题中的后面两个问题同样也适用于线程</p><p>第一个问题在线程间比较好解决，因为它们共享一个地址空间，它们具有相同的运行时环境，可以想象你在用高级语言编写多线程代码的过程中，线程通信问题是不是比较容易解决？</p><p>另外两个问题也同样适用于线程，同样的问题可用同样的方法来解决。我们后面会慢慢讨论这三个问题，你现在脑子中大致有个印象即可。</p><h3 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h3><p>在一些操作系统中，协作的进程可能共享一些彼此都能读写的公共资源。公共资源可能在内存中也可能在一个共享文件。为了讲清楚进程间是如何通信的，这里我们举一个例子：一个后台打印程序。当一个进程需要打印某个文件时，它会将文件名放在一个特殊的后台目录(spooler directory)中。另一个进程 打印后台进程(printer daemon) 会定期的检查是否需要文件被打印，如果有的话，就打印并将该文件名从目录下删除。</p><p>假设我们的后台目录有非常多的 槽位(slot)，编号依次为 0，1，2，…，每个槽位存放一个文件名。同时假设有两个共享变量：out，指向下一个需要打印的文件；in，指向目录中下个空闲的槽位。可以把这两个文件保存在一个所有进程都能访问的文件中，该文件的长度为两个字。在某一时刻，0 至 3 号槽位空，4 号至 6 号槽位被占用。在同一时刻，进程 A 和 进程 B 都决定将一个文件排队打印，情况如下</p><p><img src="/%E7%BC%96%E7%A8%8B%E7%B1%BB/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/ipc-race.png" alt="race condition"></p><p>墨菲法则(Murphy) 中说过，任何可能出错的地方终将出错，这句话生效时，可能发生如下情况。</p><p>进程 A 读到 in 的值为 7，将 7 存在一个局部变量 next_free_slot 中。此时发生一次时钟中断，CPU 认为进程 A 已经运行了足够长的时间，决定切换到进程 B 。进程 B 也读取 in 的值，发现是 7，然后进程 B 将 7 写入到自己的局部变量 next_free_slot 中，在这一时刻两个进程都认为下一个可用槽位是 7 。</p><p>进程 B 现在继续运行，它会将打印文件名写入到 slot 7 中，然后把 in 的指针更改为 8 ，然后进程 B 离开去做其他的事情</p><p>现在进程 A 开始恢复运行，由于进程 A 通过检查 next_free_slot也发现 slot 7 的槽位是空的，于是将打印文件名存入slot 7 中，然后把 in 的值更新为 8 ，由于 slot 7 这个槽位中已经有进程 B 写入的值，所以进程 A 的打印文件名会把进程 B 的文件覆盖，由于打印机内部是无法发现是哪个进程更新的，它的功能比较局限，所以这时候进程 B 永远无法打印输出，类似这种情况，**即两个或多个线程同时对一共享数据进行修改，从而影响程序运行的正确性时，这种就被称为竞态条件(race condition)**。调试竞态条件是一种非常困难的工作，因为绝大多数情况下程序运行良好，但在极少数的情况下会发生一些无法解释的奇怪现象。</p><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>不仅共享资源会造成竞态条件，事实上共享文件、共享内存也会造成竞态条件、那么该如何避免呢？或许一句话可以概括说明：禁止一个或多个进程在同一时刻对共享资源（包括共享内存、共享文件等）进行读写。换句话说，我们需要一种 互斥(mutual exclusion) 条件，这也就是说，如果一个进程在某种方式下使用共享变量和文件的话，除该进程之外的其他进程就禁止做这种事（访问统一资源）。上面问题的纠结点在于，在进程 A 对共享变量的使用未结束之前进程 B 就使用它。在任何操作系统中，为了实现互斥操作而选用适当的原语是一个主要的设计问题，接下来我们会着重探讨一下。</p><p>避免竞争问题的条件可以用一种抽象的方式去描述。大部分时间，进程都会忙于内部计算和其他不会导致竞争条件的计算。然而，有时候进程会访问共享内存或文件，或者做一些能够导致竞态条件的操作。我们把对共享内存进行访问的程序片段称作 临界区域(critical region) 或 临界区(critical section)。如果我们能够正确的操作，使两个不同进程不可能同时处于临界区，就能避免竞争条件，这也是从操作系统设计角度来进行的。</p><p>尽管上面这种设计避免了竞争条件，但是不能确保并发线程同时访问共享数据的正确性和高效性。一个好的解决方案，应该包含下面四种条件</p><ol><li>任何时候两个进程不能同时处于临界区</li><li>不应对 CPU 的速度和数量做任何假设</li><li>位于临界区外的进程不得阻塞其他进程</li><li>不能使任何进程无限等待进入临界区</li></ol><p><img src="/%E7%BC%96%E7%A8%8B%E7%B1%BB/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/ipc-critical-section.png" alt="临界区互斥"></p><p>从抽象的角度来看，我们通常希望进程的行为如上图所示，在 t1 时刻，进程 A 进入临界区，在 t2 的时刻，进程 B 尝试进入临界区，因为此时进程 A 正在处于临界区中，所以进程 B 会阻塞直到 t3 时刻进程 A 离开临界区，此时进程 B 能够允许进入临界区。最后，在 t4 时刻，进程 B 离开临界区，系统恢复到没有进程的原始状态。</p><h3 id="忙等互斥"><a href="#忙等互斥" class="headerlink" title="忙等互斥"></a>忙等互斥</h3><p>下面我们会继续探讨实现互斥的各种设计，在这些方案中，当一个进程正忙于更新其关键区域的共享内存时，没有其他进程会进入其关键区域，也不会造成影响。</p><h4 id="屏蔽中断"><a href="#屏蔽中断" class="headerlink" title="屏蔽中断"></a>屏蔽中断</h4><p>在单处理器系统上，最简单的解决方案是让每个进程在进入临界区后立即屏蔽所有中断，并在离开临界区之前重新启用它们。屏蔽中断后，时钟中断也会被屏蔽。CPU 只有发生时钟中断或其他中断时才会进行进程切换。这样，在屏蔽中断后 CPU 不会切换到其他进程。所以，一旦某个进程屏蔽中断之后，它就可以检查和修改共享内存，而不用担心其他进程介入访问共享数据。</p><p>这个方案可行吗？进程进入临界区域是由谁决定的呢？不是用户进程吗？当进程进入临界区域后，用户进程关闭中断，如果经过一段较长时间后进程没有离开，那么中断不就一直启用不了，结果会如何？可能会造成整个系统的终止。而且如果是多处理器的话，屏蔽中断仅仅对执行 disable 指令的 CPU 有效。其他 CPU 仍将继续运行，并可以访问共享内存。</p><p>另一方面，对内核来说，当它在执行更新变量或列表的几条指令期间将中断屏蔽是很方便的。例如，如果多个进程处理就绪列表中的时候发生中断，则可能会发生竞态条件的出现。所以，屏蔽中断对于操作系统本身来说是一项很有用的技术，但是对于用户线程来说，屏蔽中断却不是一项通用的互斥机制。</p><h4 id="锁变量"><a href="#锁变量" class="headerlink" title="锁变量"></a>锁变量</h4><p>作为第二种尝试，可以寻找一种软件层面解决方案。考虑有单个共享的（锁）变量，初始为值为 0 。当一个线程想要进入关键区域时，它首先会查看锁的值是否为 0 ，如果锁的值是 0 ，进程会把它设置为 1 并让进程进入关键区域。如果锁的状态是 1，进程会等待直到锁变量的值变为 0 。因此，锁变量的值是 0 则意味着没有线程进入关键区域。如果是 1 则意味着有进程在关键区域内。我们对上图修改后，如下所示</p><p><img src="/%E7%BC%96%E7%A8%8B%E7%B1%BB/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/ipc-lock.png" alt="ipc"></p><p>这种设计方式是否正确呢？是否存在纰漏呢？假设一个进程读出锁变量的值并发现它为 0 ，而恰好在它将其设置为 1 之前，另一个进程调度运行，读出锁的变量为0 ，并将锁的变量设置为 1 。然后第一个线程运行，把锁变量的值再次设置为 1，此时，临界区域就会有两个进程在同时运行。</p><p><img src="/%E7%BC%96%E7%A8%8B%E7%B1%BB/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/ipc-lock2.png" alt="ipc"></p><p>也许有的读者可以这么认为，在进入前检查一次，在要离开的关键区域再检查一次不就解决了吗？实际上这种情况也是于事无补，因为在第二次检查期间其他线程仍有可能修改锁变量的值，换句话说，这种 set-before-check 不是一种 原子性 操作，所以同样还会发生竞争条件。</p><h4 id="严格轮询法"><a href="#严格轮询法" class="headerlink" title="严格轮询法"></a>严格轮询法</h4><p>第三种互斥的方式先抛出来一段代码，这里的程序是用 C 语言编写，之所以采用 C 是因为操作系统普遍是用 C 来编写的（偶尔会用 C++），而基本不会使用 Java 、Modula3 或 Pascal 这样的语言，Java 中的 native 关键字底层也是 C 或 C++ 编写的源码。对于编写操作系统而言，需要使用 C 语言这种强大、高效、可预知和有特性的语言，而对于 Java ，它是不可预知的，因为它在关键时刻会用完存储器，而在不合适的时候会调用垃圾回收机制回收内存。在 C 语言中，这种情况不会发生，C 语言中不会主动调用垃圾回收回收内存。</p><h5 id="进程-0-的代码"><a href="#进程-0-的代码" class="headerlink" title="进程 0 的代码"></a>进程 0 的代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">  <span class="keyword">while</span>(turn != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">/* 进入关键区域 */</span></span><br><span class="line">    critical_region();</span><br><span class="line">    turn = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* 离开关键区域 */</span></span><br><span class="line">    noncritical_region();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="进程-1-的代码"><a href="#进程-1-的代码" class="headerlink" title="进程 1 的代码"></a>进程 1 的代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">  <span class="keyword">while</span>(turn != <span class="number">1</span>)&#123;</span><br><span class="line">    critical_region();</span><br><span class="line">    turn = <span class="number">0</span>;</span><br><span class="line">    noncritical_region();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面代码中，变量 turn，初始值为 0 ，用于记录轮到那个进程进入临界区，并检查或更新共享内存。开始时，进程 0 检查 turn，发现其值为 0 ，于是进入临界区。进程 1 也发现其值为 0 ，所以在一个等待循环中不停的测试 turn，看其值何时变为 1。连续检查一个变量直到某个值出现为止，这种方法称为 忙等待(busywaiting)。由于这种方式浪费 CPU 时间，所以这种方式通常应该要避免。只有在有理由认为等待时间是非常短的情况下，才能够使用忙等待。用于忙等待的锁，称为 自旋锁(spinlock)。</p><p>进程 0 离开临界区时，它将 turn 的值设置为 1，以便允许进程 1 进入其临界区。假设进程 1 很快便离开了临界区，则此时两个进程都处于临界区之外，turn 的值又被设置为 0 。现在进程 0 很快就执行完了整个循环，它退出临界区，并将 turn 的值设置为 1。此时，turn 的值为 1，两个进程都在其临界区外执行。</p><p>突然，进程 0 结束了非临界区的操作并返回到循环的开始。但是，这时它不能进入临界区，因为 turn 的当前值为 1，此时进程 1 还忙于非临界区的操作，进程 0 只能继续 while 循环，直到进程 1 把 turn 的值改为 0 。这说明，在一个进程比另一个进程执行速度慢了很多的情况下，轮流进入临界区并不是一个好的方法。</p><p>这种情况违反了前面的叙述 3 ，即 位于临界区外的进程不得阻塞其他进程，进程 0 被一个临界区外的进程阻塞。由于违反了第三条，所以也不能作为一个好的方案。</p><h4 id="Peterson-解法"><a href="#Peterson-解法" class="headerlink" title="Peterson 解法"></a>Peterson 解法</h4><p>荷兰数学家 T.Dekker 通过将锁变量与警告变量相结合，最早提出了一个不需要严格轮换的软件互斥算法</p><p>后来， G.L.Peterson 发现了一种简单很多的互斥算法，它的算法如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE  1</span></span><br><span class="line"><span class="comment">/* 进程数量 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N     2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 现在轮到谁 */</span></span><br><span class="line"><span class="keyword">int</span> turn;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 所有值初始化为 0 (FALSE) */</span></span><br><span class="line"><span class="keyword">int</span> interested[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 进程是 0 或 1 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enter_region</span><span class="params">(<span class="keyword">int</span> process)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 另一个进程号 */</span></span><br><span class="line">  <span class="keyword">int</span> other;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 另一个进程 */</span></span><br><span class="line">  other = <span class="number">1</span> - process;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 表示愿意进入临界区 */</span></span><br><span class="line">  interested[process] = TRUE;</span><br><span class="line">  turn = process;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 空循环 */</span></span><br><span class="line">  <span class="keyword">while</span>(turn == process </span><br><span class="line">        &amp;&amp; interested[other] == <span class="literal">true</span>)&#123;&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leave_region</span><span class="params">(<span class="keyword">int</span> process)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 表示离开临界区 */</span></span><br><span class="line">  interested[process] == FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用共享变量时（即进入其临界区）之前，各个进程使用各自的进程号 0 或 1 作为参数来调用 enter_region，这个函数调用在需要时将使进程等待，直到能够安全的临界区。在完成对共享变量的操作之后，进程将调用 leave_region 表示操作完成，并且允许其他进程进入。</p><p>现在来看看这个办法是如何工作的。一开始，没有任何进程处于临界区中，现在进程 0 调用 enter_region。它通过设置数组元素和将 turn 置为 0 来表示它希望进入临界区。由于进程 1 并不想进入临界区，所以 enter_region 很快便返回。如果进程现在调用 enter_region，进程 1 将在此处挂起直到 interested[0] 变为 FALSE，这种情况只有在进程 0 调用 leave_region 退出临界区时才会发生。</p><p>那么上面讨论的是顺序进入的情况，现在来考虑一种两个进程同时调用 enter_region 的情况。它们都将自己的进程存入 turn，但只有最后保存进去的进程号才有效，前一个进程的进程号因为重写而丢失。假如进程 1 是最后存入的，则 turn 为 1 。当两个进程都运行到 while 的时候，进程 0 将不会循环并进入临界区，而进程 1 将会无限循环且不会进入临界区，直到进程 0 退出位置。</p><h4 id="TSL-指令"><a href="#TSL-指令" class="headerlink" title="TSL 指令"></a>TSL 指令</h4><p>现在来看一种需要硬件帮助的方案。一些计算机，特别是那些设计为多处理器的计算机，都会有下面这条指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TSL RX,LOCK</span><br></pre></td></tr></table></figure><p>称为 测试并加锁(test and set lock)，它将一个内存字 lock 读到寄存器 RX 中，然后在该内存地址上存储一个非零值。读写指令能保证是一体的，不可分割的，一同执行的。在这个指令结束之前其他处理器均不允许访问内存。执行 TSL 指令的 CPU 将会锁住内存总线，用来禁止其他 CPU 在这个指令结束之前访问内存。</p><p>很重要的一点是锁住内存总线和禁用中断不一样。禁用中断并不能保证一个处理器在读写操作之间另一个处理器对内存的读写。也就是说，在处理器 1 上屏蔽中断对处理器 2 没有影响。让处理器 2 远离内存直到处理器 1 完成读写的最好的方式就是锁住总线。这需要一个特殊的硬件（基本上，一根总线就可以确保总线由锁住它的处理器使用，而其他的处理器不能使用）</p><p>为了使用 TSL 指令，要使用一个共享变量 lock 来协调对共享内存的访问。当 lock 为 0 时，任何进程都可以使用 TSL 指令将其设置为 1，并读写共享内存。当操作结束时，进程使用 move 指令将 lock 的值重新设置为 0 。</p><p>这条指令如何防止两个进程同时进入临界区呢？下面是解决方案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">enter_region:</span><br><span class="line">            | 复制锁到寄存器并将锁设为1</span><br><span class="line">            TSL REGISTER,LOCK              </span><br><span class="line">            | 锁是 0 吗？</span><br><span class="line">        CMP REGISTER,#0</span><br><span class="line">        | 若不是零，说明锁已被设置，所以循环</span><br><span class="line">        JNE enter_region</span><br><span class="line">        | 返回调用者，进入临界区</span><br><span class="line">        RET </span><br><span class="line"></span><br><span class="line">leave_region:</span><br><span class="line"></span><br><span class="line">            | 在锁中存入 0</span><br><span class="line">            MOVE LOCK,#0     </span><br><span class="line">      | 返回调用者</span><br><span class="line">        RET</span><br></pre></td></tr></table></figure><p>我们可以看到这个解决方案的思想和 Peterson 的思想很相似。假设存在如下共 4 指令的汇编语言程序。第一条指令将 lock 原来的值复制到寄存器中并将 lock 设置为 1 ，随后这个原来的值和 0 做对比。如果它不是零，说明之前已经被加过锁，则程序返回到开始并再次测试。经过一段时间后（可长可短），该值变为 0 （当前处于临界区中的进程退出临界区时），于是过程返回，此时已加锁。要清除这个锁也比较简单，程序只需要将 0 存入 lock 即可，不需要特殊的同步指令。</p><p>现在有了一种很明确的做法，那就是进程在进入临界区之前会先调用 enter_region，判断是否进行循环，如果lock 的值是 1 ，进行无限循环，如果 lock 是 0，不进入循环并进入临界区。在进程从临界区返回时它调用 leave_region，这会把 lock 设置为 0 。与基于临界区问题的所有解法一样，进程必须在正确的时间调用 enter_region 和 leave_region ，解法才能奏效。</p><p>还有一个可以替换 TSL 的指令是 XCHG，它原子性的交换了两个位置的内容，例如，一个寄存器与一个内存字，代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">enter_region:</span><br><span class="line">        | 把 1 放在内存器中</span><br><span class="line">        MOVE REGISTER,#1</span><br><span class="line">    | 交换寄存器和锁变量的内容</span><br><span class="line">        XCHG REGISTER,LOCK</span><br><span class="line">    | 锁是 0 吗？</span><br><span class="line">        CMP REGISTER,#0</span><br><span class="line">    | 若不是 0 ，锁已被设置，进行循环</span><br><span class="line">        JNE enter_region</span><br><span class="line">    | 返回调用者，进入临界区</span><br><span class="line">        RET</span><br><span class="line">        </span><br><span class="line">leave_region:</span><br><span class="line">        | 在锁中存入 0 </span><br><span class="line">        MOVE LOCK,#0</span><br><span class="line">    | 返回调用者</span><br><span class="line">        RET</span><br></pre></td></tr></table></figure><p>XCHG 的本质上与 TSL 的解决办法一样。所有的 Intel x86 CPU 在底层同步中使用 XCHG 指令。</p><h3 id="睡眠与唤醒"><a href="#睡眠与唤醒" class="headerlink" title="睡眠与唤醒"></a>睡眠与唤醒</h3><p>上面解法中的 Peterson 、TSL 和 XCHG 解法都是正确的，但是它们都有忙等待的缺点。这些解法的本质上都是一样的，先检查是否能够进入临界区，若不允许，则该进程将原地等待，直到允许为止。</p><p>这种方式不但浪费了 CPU 时间，而且还可能引起意想不到的结果。考虑一台计算机上有两个进程，这两个进程具有不同的优先级，H 是属于优先级比较高的进程，L 是属于优先级比较低的进程。进程调度的规则是不论何时只要 H 进程处于就绪态 H 就开始运行。在某一时刻，L 处于临界区中，此时 H 变为就绪态，准备运行（例如，一条 I/O 操作结束）。现在 H 要开始忙等，但由于当 H 就绪时 L 就不会被调度，L 从来不会有机会离开关键区域，所以 H 会变成死循环，有时将这种情况称为优先级反转问题(priority inversion problem)。</p><p>现在让我们看一下进程间的通信原语，这些原语在不允许它们进入关键区域之前会阻塞而不是浪费 CPU 时间，最简单的是 sleep 和 wakeup。Sleep 是一个能够造成调用者阻塞的系统调用，也就是说，这个系统调用会暂停直到其他进程唤醒它。wakeup 调用有一个参数，即要唤醒的进程。还有一种方式是 wakeup 和 sleep 都有一个参数，即 sleep 和 wakeup 需要匹配的内存地址。</p><h4 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h4><p>作为这些私有原语的例子，让我们考虑生产者-消费者(producer-consumer) 问题，也称作 有界缓冲区(bounded-buffer) 问题。两个进程共享一个公共的固定大小的缓冲区。其中一个是生产者(producer)，将信息放入缓冲区， 另一个是消费者(consumer) ，会从缓冲区中取出。也可以把这个问题一般化为 m 个生产者和 n 个消费者的问题，但是我们这里只讨论一个生产者和一个消费者的情况，这样可以简化实现方案。</p><p>如果缓冲队列已满，那么当生产者仍想要将数据写入缓冲区的时候，会出现问题。它的解决办法是让生产者睡眠，也就是阻塞生产者。等到消费者从缓冲区中取出一个或多个数据项时再唤醒它。同样的，当消费者试图从缓冲区中取数据，但是发现缓冲区为空时，消费者也会睡眠，阻塞。直到生产者向其中放入一个新的数据。</p><p>这个逻辑听起来比较简单，而且这种方式也需要一种称作 监听 的变量，这个变量用于监视缓冲区的数据，我们暂定为 count，如果缓冲区最多存放 N 个数据项，生产者会每次判断 count 是否达到 N，否则生产者向缓冲区放入一个数据项并增量 count 的值。消费者的逻辑也很相似：首先测试 count 的值是否为 0 ，如果为 0 则消费者睡眠、阻塞，否则会从缓冲区取出数据并使 count 数量递减。每个进程也会检查检查是否其他线程是否应该被唤醒，如果应该被唤醒，那么就唤醒该线程。下面是生产者消费者的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 缓冲区 slot 槽的数量 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"><span class="comment">/* 缓冲区数据的数量 */</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="keyword">void</span> producer(<span class="keyword">void</span>)&#123;</span><br><span class="line">  <span class="keyword">int</span> item;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 无限循环 */</span></span><br><span class="line">  <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">    <span class="comment">/* 生成下一项数据 */</span></span><br><span class="line">    item = produce_item()</span><br><span class="line">    <span class="comment">/* 如果缓存区是满的，就会阻塞 */</span></span><br><span class="line">    <span class="keyword">if</span>(count == N)&#123;</span><br><span class="line">      sleep();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 把当前数据放在缓冲区中 */</span></span><br><span class="line">    insert_item(item);</span><br><span class="line">    <span class="comment">/* 增加缓冲区 count 的数量 */</span></span><br><span class="line">    count = count + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">1</span>)&#123;</span><br><span class="line">      <span class="comment">/* 缓冲区是否为空？ */</span></span><br><span class="line">      wakeup(consumer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> item;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 无限循环 */</span></span><br><span class="line">  <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">    <span class="comment">/* 如果缓冲区是空的，就会进行阻塞 */</span></span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">      sleep();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 从缓冲区中取出一个数据 */</span></span><br><span class="line">    item = remove_item();</span><br><span class="line">    <span class="comment">/* 将缓冲区的 count 数量减一 */</span></span><br><span class="line">    count = count - <span class="number">1</span></span><br><span class="line">    <span class="comment">/* 缓冲区满嘛？ */</span></span><br><span class="line">    <span class="keyword">if</span>(count == N - <span class="number">1</span>)&#123;</span><br><span class="line">      wakeup(producer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 打印数据项 */</span></span><br><span class="line">    consumer_item(item);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了在 C 语言中描述像是 sleep 和 wakeup 的系统调用，我们将以库函数调用的形式来表示。它们不是 C 标准库的一部分，但可以在实际具有这些系统调用的任何系统上使用。代码中未实现的 insert_item 和 remove_item 用来记录将数据项放入缓冲区和从缓冲区取出数据等。</p><p>现在让我们回到生产者-消费者问题上来，上面代码中会产生竞争条件，因为 count 这个变量是暴露在大众视野下的。有可能出现下面这种情况：缓冲区为空，此时消费者刚好读取 count 的值发现它为 0 。此时调度程序决定暂停消费者并启动运行生产者。生产者生产了一条数据并把它放在缓冲区中，然后增加 count 的值，并注意到它的值是 1 。由于 count 为 0，消费者必须处于睡眠状态，因此生产者调用 wakeup 来唤醒消费者。但是，消费者此时在逻辑上并没有睡眠，所以 wakeup 信号会丢失。当消费者下次启动后，它会查看之前读取的 count 值，发现它的值是 0 ，然后在此进行睡眠。不久之后生产者会填满整个缓冲区，在这之后会阻塞，这样一来两个进程将永远睡眠下去。</p><p>引起上面问题的本质是 <strong>唤醒尚未进行睡眠状态的进程会导致唤醒丢失</strong>。如果它没有丢失，则一切都很正常。一种快速解决上面问题的方式是增加一个唤醒等待位(wakeup waiting bit)。当一个 wakeup 信号发送给仍在清醒的进程后，该位置为 1 。之后，当进程尝试睡眠的时候，如果唤醒等待位为 1 ，则该位清除，而进程仍然保持清醒。</p><p>然而，当进程数量有许多的时候，这时你可以说通过增加唤醒等待位的数量来唤醒等待位，于是就有了 2、4、6、8 个唤醒等待位，但是并没有从根本上解决问题。</p>]]></content>
      
      
      <categories>
          
          <category> 编程类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多进程 </tag>
            
            <tag> IPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown技巧</title>
      <link href="/Markdown/Markdown%E6%8A%80%E5%B7%A7/"/>
      <url>/Markdown/Markdown%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>=====<br>    一级标题<br>    ==============<br>    二级标题<br>    ————-</p><pre><code># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题</code></pre><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><p>换行是使用两个以上空格加上回车。</p><p>或者空一行</p><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><pre><code>*斜体文本*_斜体文本_**粗体文本**__粗体文本__***粗斜体文本***___粗斜体文本___</code></pre><h2 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h2><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p><pre><code>**** * *- - -</code></pre><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：</p><p><code>~~文本~~</code>  </p><p><del>文本</del></p><h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><p>下划线可以通过 HTML 的 <code>&lt;u&gt;</code>标签来实现：</p><pre><code>&lt;u&gt;带下划线文本&lt;/u&gt;</code></pre><p><u>带下划线文本</u></p><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><p>脚注是对文本的补充说明。</p><p>Markdown 脚注的格式如下:</p><p><code>[^要注明的文本]</code>  </p><p>加油吧，骚年！<a href="Author">^Danny</a>。</p><h2 id="字体-1"><a href="#字体-1" class="headerlink" title="字体"></a>字体</h2><p><font face="微软雅黑" size="3" color="#FF0000">博客同名的文件夹</font></p><h2 id="Markdown-支持有序列表和无序列表"><a href="#Markdown-支持有序列表和无序列表" class="headerlink" title="Markdown 支持有序列表和无序列表"></a>Markdown 支持有序列表和无序列表</h2><p>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容：</p><pre><code>* 第一项* 第二项* 第三项+ 第一项+ 第二项+ 第三项- 第一项- 第二项- 第三项</code></pre><p>有序列表使用数字并加上 . 号来表示，如：</p><pre><code>1. 第一项2. 第二项3. 第三项</code></pre><h2 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h2><p>列表嵌套只需在子列表中的选项前面添加四个空格即可：</p><pre><code>1. 第一项：    - 第一项嵌套的第一个元素    - 第一项嵌套的第二个元素2. 第二项：    - 第二项嵌套的第一个元素    - 第二项嵌套的第二个元素</code></pre><h2 id="Markdown-区块"><a href="#Markdown-区块" class="headerlink" title="Markdown 区块"></a>Markdown 区块</h2><p>Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号：</p><blockquote><p>buzzword<br>open source<br>halo</p></blockquote><p>另外区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推：</p><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套</p></blockquote></blockquote></blockquote><h2 id="区块中使用列表"><a href="#区块中使用列表" class="headerlink" title="区块中使用列表"></a>区块中使用列表</h2><p>区块中使用列表实例如下：</p><pre><code>&gt; 区块中使用列表  &gt; 1. 第一项  &gt; 2. 第二项  &gt; + 第一项  &gt; + 第二项  &gt; + 第三项  </code></pre><h2 id="列表中使用区块"><a href="#列表中使用区块" class="headerlink" title="列表中使用区块"></a>列表中使用区块</h2><p>如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进。</p><p>列表中使用区块实例如下：</p><pre><code>* 第一项    &gt; buzzword    &gt; halo* 第二项</code></pre><h2 id="Markdown-代码"><a href="#Markdown-代码" class="headerlink" title="Markdown 代码"></a>Markdown 代码</h2><p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`），例如：</p><p><code>printf()</code> 函数</p><p>代码区块<br>代码区块使用 4 个空格或者一个制表符（Tab 键）。  </p><pre><code>print(&#39;hello world!&#39;)</code></pre><p>你也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;RUNOOB&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Markdown 链接<br>链接使用方法如下：</p><pre><code>[链接名称](链接地址)</code></pre><p>或者</p><pre><code>&lt;链接地址&gt;</code></pre><p>例如：</p><pre><code>这是一个链接 [百度](https://www.baidu.com)</code></pre><p>这是一个链接 <a href="https://www.baidu.com/">百度</a></p><p>直接使用链接地址：</p><pre><code>&lt;https://www.baidu.com&gt;</code></pre><p><a href="https://www.baidu.com/">https://www.baidu.com</a></p><p>高级链接<br>我们可以通过变量来设置一个链接，变量赋值在文档末尾进行：</p><pre><code>这个链接用 1 作为网址变量 [baidu][1]</code></pre><p>然后在文档的结尾为变量赋值（网址）</p><p>Markdown 图片<br>Markdown 图片语法格式如下：</p><p><img src="/Markdown/Markdown%E6%8A%80%E5%B7%A7/%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80" alt="alt 属性文本"></p><p><img src="/Markdown/Markdown%E6%8A%80%E5%B7%A7/%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80" alt="alt 属性文本" title="可选标题"><br>开头一个感叹号 !<br>接着一个方括号，里面放上图片的替代文字<br>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。<br>使用实例：</p><p>![百度 logo][2]</p><p>Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 <code>&lt;img&gt;</code> 标签。</p><pre><code>&lt;img src=&quot;https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png&quot; width=&quot;50%&quot;&gt;</code></pre><img src="https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png" width="50%"><pre><code>[1]: http://www.baidu.com/[2]: https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png</code></pre><h2 id="Markdown-表格"><a href="#Markdown-表格" class="headerlink" title="Markdown 表格"></a>Markdown 表格</h2><p>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。</p><p>语法格式如下：</p><pre><code>|  左对齐   | 居中  | 右对齐  ||  :----  | :----:  | ----:  || 单元格  | 单元格 | 单元格 || 单元格  | 单元格 | 单元格 |</code></pre><table><thead><tr><th align="left">表头</th><th align="center">表头</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="center">单元格</td></tr></tbody></table><h2 id="Markdown-高级技巧"><a href="#Markdown-高级技巧" class="headerlink" title="Markdown 高级技巧"></a>Markdown 高级技巧</h2><p>支持的 HTML 元素</p><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。</p><p>目前支持的 HTML 元素有：</p><pre><code>&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等 ，</code></pre><p>如：</p><pre><code>&lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; </code></pre><p>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p><h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：</p><pre><code>**文本加粗** \*\* 正常显示星号 \*\*</code></pre><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><pre><code>\   反斜线`   反引号*   星号_   下划线&#123;&#125;  花括号[]  方括号()  小括号#   井字号+   加号-   减号.   英文句点!   感叹号</code></pre><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：</p><p>$$<br>\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix}<br>\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \<br>\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \<br>\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \<br>\end{vmatrix}<br>{\style{visibility:hidden}{(x+1)(x+1)}}<br>$$<br>$$<br>\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix}<br>\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \<br>\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \<br>\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \<br>\end{vmatrix}<br>{\style{visibility:hidden}{(x+1)(x+1)}}<br>$$</p><h3 id="1、横向流程图源码格式"><a href="#1、横向流程图源码格式" class="headerlink" title="1、横向流程图源码格式"></a>1、横向流程图源码格式</h3><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[方形] --&gt;B(圆角)</span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line">    C --&gt;|a=1| D[结果1]</span><br><span class="line">    C --&gt;|a=2| E[结果2]</span><br><span class="line">    F[横向流程图]</span><br></pre></td></tr></table></figure></code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A[方形] --&gt;B(圆角)</span><br><span class="line">        B --&gt; C&#123;条件a&#125;</span><br><span class="line">        C --&gt;|a=1| D[结果1]</span><br><span class="line">        C --&gt;|a=2| E[结果2]</span><br><span class="line">        F[横向流程图]</span><br></pre></td></tr></table></figure><h3 id="2、竖向流程图源码格式"><a href="#2、竖向流程图源码格式" class="headerlink" title="2、竖向流程图源码格式"></a>2、竖向流程图源码格式</h3><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[方形] --&gt; B(圆角)</span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line">    C --&gt; |a=1| D[结果1]</span><br><span class="line">    C --&gt; |a=2| E[结果2]</span><br><span class="line">    F[竖向流程图]</span><br></pre></td></tr></table></figure></code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[方形] --&gt; B(圆角)</span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line">    C --&gt; |a=1| D[结果1]</span><br><span class="line">    C --&gt; |a=2| E[结果2]</span><br><span class="line">    F[竖向流程图]</span><br></pre></td></tr></table></figure><h3 id="3、标准流程图源码格式"><a href="#3、标准流程图源码格式" class="headerlink" title="3、标准流程图源码格式"></a>3、标准流程图源码格式</h3><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 开始框  </span><br><span class="line">op=&gt;operation: 处理框  </span><br><span class="line">cond=&gt;condition: 判断框(是或否?)  </span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line">e=&gt;end: 结束框</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure></code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 开始框  </span><br><span class="line">op=&gt;operation: 处理框  </span><br><span class="line">cond=&gt;condition: 判断框(是或否?)  </span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line">e=&gt;end: 结束框</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure><h3 id="4、标准流程图源码格式（横向）"><a href="#4、标准流程图源码格式（横向）" class="headerlink" title="4、标准流程图源码格式（横向）"></a>4、标准流程图源码格式（横向）</h3><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 开始框</span><br><span class="line">op=&gt;operation: 处理框</span><br><span class="line">cond=&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line">e=&gt;end: 结束框</span><br><span class="line">st(right)-&gt;op(right)-&gt;cond</span><br><span class="line">cond(yes)-&gt;io(bottom)-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure></code></pre> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 开始框</span><br><span class="line">op=&gt;operation: 处理框</span><br><span class="line">cond=&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line">e=&gt;end: 结束框</span><br><span class="line">st(right)-&gt;op(right)-&gt;cond</span><br><span class="line">cond(yes)-&gt;io(bottom)-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure><h3 id="5、UML时序图源码样例"><a href="#5、UML时序图源码样例" class="headerlink" title="5、UML时序图源码样例"></a>5、UML时序图源码样例</h3><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对象A-&gt;对象B: 对象B你好吗?（请求）</span><br><span class="line">Note right of 对象B: 对象B的描述</span><br><span class="line">Note left of 对象A: 对象A的描述(提示)</span><br><span class="line">对象B--&gt;对象A: 我很好(响应)</span><br><span class="line">对象A-&gt;对象B: 你真的好吗？</span><br></pre></td></tr></table></figure></code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对象A-&gt;对象B: 对象B你好吗?（请求）</span><br><span class="line">Note right of 对象B: 对象B的描述</span><br><span class="line">Note left of 对象A: 对象A的描述(提示)</span><br><span class="line">对象B--&gt;对象A: 我很好(响应)</span><br><span class="line">对象A-&gt;对象B: 你真的好吗？</span><br></pre></td></tr></table></figure><h3 id="6、UML时序图源码复杂样例"><a href="#6、UML时序图源码复杂样例" class="headerlink" title="6、UML时序图源码复杂样例"></a>6、UML时序图源码复杂样例</h3><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Title: 标题：复杂使用</span><br><span class="line">对象A-&gt;对象B: 对象B你好吗?（请求）</span><br><span class="line">Note right of 对象B: 对象B的描述</span><br><span class="line">Note left of 对象A: 对象A的描述(提示)</span><br><span class="line">对象B--&gt;对象A: 我很好(响应)</span><br><span class="line">对象B-&gt;小三: 你好吗</span><br><span class="line">小三--&gt;&gt;对象A: 对象B找我了</span><br><span class="line">对象A-&gt;对象B: 你真的好吗？</span><br><span class="line">Note over 小三,对象B: 我们是朋友</span><br><span class="line">participant C</span><br><span class="line">Note right of C: 没人陪我玩</span><br></pre></td></tr></table></figure></code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Title: 标题：复杂使用</span><br><span class="line">对象A-&gt;对象B: 对象B你好吗?（请求）</span><br><span class="line">Note right of 对象B: 对象B的描述</span><br><span class="line">Note left of 对象A: 对象A的描述(提示)</span><br><span class="line">对象B--&gt;对象A: 我很好(响应)</span><br><span class="line">对象B-&gt;小三: 你好吗</span><br><span class="line">小三--&gt;&gt;对象A: 对象B找我了</span><br><span class="line">对象A-&gt;对象B: 你真的好吗？</span><br><span class="line">Note over 小三,对象B: 我们是朋友</span><br><span class="line">participant C</span><br><span class="line">Note right of C: 没人陪我玩</span><br></pre></td></tr></table></figure><h3 id="7、UML标准时序图样例"><a href="#7、UML标准时序图样例" class="headerlink" title="7、UML标准时序图样例"></a>7、UML标准时序图样例</h3><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头</span><br><span class="line">    sequenceDiagram</span><br><span class="line">    participant 张三</span><br><span class="line">    participant 李四</span><br><span class="line">    张三-&gt;王五: 王五你好吗？</span><br><span class="line">    loop 健康检查</span><br><span class="line">        王五-&gt;王五: 与疾病战斗</span><br><span class="line">    end</span><br><span class="line">    Note right of 王五: 合理 食物 &lt;br/&gt;看医生...</span><br><span class="line">    李四--&gt;&gt;张三: 很好!</span><br><span class="line">    王五-&gt;李四: 你怎么样?</span><br><span class="line">    李四--&gt;王五: 很好!</span><br></pre></td></tr></table></figure></code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头</span><br><span class="line">    sequenceDiagram</span><br><span class="line">    participant 张三</span><br><span class="line">    participant 李四</span><br><span class="line">    张三-&gt;王五: 王五你好吗？</span><br><span class="line">    loop 健康检查</span><br><span class="line">        王五-&gt;王五: 与疾病战斗</span><br><span class="line">    end</span><br><span class="line">    Note right of 王五: 合理 食物 &lt;br/&gt;看医生...</span><br><span class="line">    李四--&gt;&gt;张三: 很好!</span><br><span class="line">    王五-&gt;李四: 你怎么样?</span><br><span class="line">    李四--&gt;王五: 很好!</span><br></pre></td></tr></table></figure><h3 id="8、甘特图样例"><a href="#8、甘特图样例" class="headerlink" title="8、甘特图样例"></a>8、甘特图样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">```mermaid</span><br><span class="line">%% 语法示例</span><br><span class="line">        gantt</span><br><span class="line">        dateFormat  YYYY-MM-DD</span><br><span class="line">        title 软件开发甘特图</span><br><span class="line">        section 设计</span><br><span class="line">        需求                      :done,    des1, 2014-01-06,2014-01-08</span><br><span class="line">        原型                      :active,  des2, 2014-01-09, 3d</span><br><span class="line">        UI设计                     :         des3, after des2, 5d</span><br><span class="line">    未来任务                     :         des4, after des3, 5d</span><br><span class="line">        section 开发</span><br><span class="line">        学习准备理解需求                      :crit, done, 2014-01-06,24h</span><br><span class="line">        设计框架                             :crit, done, after des2, 2d</span><br><span class="line">        开发                                 :crit, active, 3d</span><br><span class="line">        未来任务                              :crit, 5d</span><br><span class="line">        耍                                   :2d</span><br><span class="line">        section 测试</span><br><span class="line">        功能测试                              :active, a1, after des3, 3d</span><br><span class="line">        压力测试                               :after a1  , 20h</span><br><span class="line">        测试报告                               : 48h</span><br><span class="line">```</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo常见问题</title>
      <link href="/hexo/hexo%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/hexo/hexo%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><p>1.安装Git<br>2.安装Node.js<br>3.安装Hexo</p><pre><code>npm install -g hexo-clihexo init myblog</code></pre><h2 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h2><pre><code>url: https://dannysunsan.github.io/permalink: :category/:title/pretty_urls:trailing_index: false # Set to false to remove trailing &#39;index.html&#39; from permalinkstrailing_html: false # Set to false to remove trailing &#39;.html&#39; from permalinksdefault_category: binpost_asset_folder: truetheme: mihodeploy:type: git    repository: https://github.com/DannySunsan/DannySunsan.github.io.git    branch: gh-pages</code></pre><h2 id="3-部署"><a href="#3-部署" class="headerlink" title="3. 部署"></a>3. 部署</h2><pre><code>hexo clean //清除生成，每次重新部署前需要执行hexo g     //生成hexo d     //执行</code></pre><h2 id="4-写作"><a href="#4-写作" class="headerlink" title="4. 写作"></a>4. 写作</h2><h3 id="tags-amp-categories"><a href="#tags-amp-categories" class="headerlink" title="tags &amp; categories"></a>tags &amp; categories</h3><pre><code>hexo new page tags修改tags/index.md 里面的内容为---title: 文章标签date: 2021-11-22 14:56:48type: &quot;tags&quot;---hexo new page categories修改categories/index.md 里面的内容为---title: 文章分类date: 2021-11-22 14:56:48type: &quot;categories&quot;---hexo new page about修改about/index.md 里面的内容为---title: 关于date: 2021-11-22 14:56:48type: &quot;categories&quot;---hexo new newpapername</code></pre><h2 id="内插图片"><a href="#内插图片" class="headerlink" title="内插图片"></a>内插图片</h2><p>1.将Hexo目录下的配置文件_config.yml里的psot_asset_folder:设置为true。</p><p>2.在Hexo目录下执行:</p><pre><code>npm install https://github.com/CodeFalling/hexo-asset-image</code></pre><p>下面的命令有bug</p><pre><code>npm install hexo-asset-image --save</code></pre><p>3.执行hexo n “博客名”生成博客，此时在_post目录会生成与 <font face="微软雅黑" size="3" color="#FF0000">博客同名的文件夹</font>。</p><p>4.将博客需要使用的图片移动到<font face="微软雅黑" size="3" color="#FF0000">博客同名的文件夹</font>中，然后在博客中使用Markdown的格式引用</p><pre><code>![图片描述文字](图片名.jpg)</code></pre><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p><a href="https://hexo.io/themes/">官网</a></p><h2 id="部分插件"><a href="#部分插件" class="headerlink" title="部分插件"></a>部分插件</h2><p>1.algolia</p><p>安装</p><pre><code>npm install --save hexo-algolia</code></pre><p><a href="https://www.algolia.com/users/sign_in">注册</a></p><p>1.点击Indices，新建Index<br>2.点击API Keys，记录下以下三个值：</p><pre><code>Application IDSearch-Only API KeyAdmin API Key</code></pre><p>在API Keys页面切换“All API Keys”，新建一个Key，勾选下图所示的权限，并记录下API key的值。<br>由于更新后的algolia为了安全原因，需要新建一个专用的Key提交搜索数据库的，否则会出现提交失败的情况。</p><p>当配置完成后，输入如下指令：</p><pre><code>export HEXO_ALGOLIA_INDEXING_KEY=…</code></pre><p>“=”后面填入新建的API，完成后在站点根目录下执行 hexo algolia 来更新 Index。请注意观察命令的输出。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程总结</title>
      <link href="/%E7%BC%96%E7%A8%8B%E7%B1%BB/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
      <url>/%E7%BC%96%E7%A8%8B%E7%B1%BB/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="经典的线程模型"><a href="#经典的线程模型" class="headerlink" title="经典的线程模型"></a>经典的线程模型</h2><p>理解进程的另一个角度是，用某种方法把相关的资源集中在一起。进程有存放程序正文和数据以及其他资源的地址空间。这些资源包括打开的文件、子进程、即将发生的定时器、信号处理程序、账号信息等。把这些信息放在进程中会比较容易管理。</p><p>另一个概念是，进程中拥有一个执行的线程，通常简写为 线程(thread)。线程会有程序计数器，用来记录接着要执行哪一条指令；线程还拥有寄存器，用来保存线程当前正在使用的变量；线程还会有堆栈，用来记录程序的执行路径。尽管线程必须在某个进程中执行，但是进程和线程完完全全是两个不同的概念，并且他们可以分开处理。进程用于把资源集中在一起，而线程则是 CPU 上调度执行的实体。</p><p>线程给进程模型增加了一项内容，即在同一个进程中，允许彼此之间有较大的独立性且互不干扰。在一个进程中并行运行多个线程类似于在一台计算机上运行多个进程。在多个线程中，各个线程共享同一地址空间和其他资源。在多个进程中，进程共享物理内存、磁盘、打印机和其他资源。因为线程会包含有一些进程的属性，所以线程被称为轻量的进程(lightweight processes)。多线程(multithreading)一词还用于描述在同一进程中多个线程的情况。</p><p>下图我们可以看到三个传统的进程，每个进程有自己的地址空间和单个控制线程。每个线程都在不同的地址空间中运行。</p><p><img src="/%E7%BC%96%E7%A8%8B%E7%B1%BB/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/multi-th-ThreePro-OneTh.png" alt="three-one"></p><p>下图中，我们可以看到有一个进程三个线程的情况。每个线程都在相同的地址空间中运行。</p><p><img src="/%E7%BC%96%E7%A8%8B%E7%B1%BB/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/multi-th-OnePro-OneTh.png" alt="one-one"></p><p>线程不像是进程那样具备较强的独立性。同一个进程中的所有线程都会有完全一样的地址空间，这意味着它们也共享同样的全局变量。由于每个线程都可以访问进程地址空间内每个内存地址，因此一个线程可以读取、写入甚至擦除另一个线程的堆栈。线程之间除了共享同一内存空间外，还具有如下不同的内容</p><table><thead><tr><th align="center">每个进程中的内容</th><th align="center">每个线程中的内容</th></tr></thead><tbody><tr><td align="center">地址空间</td><td align="center">程序计数器</td></tr><tr><td align="center">全局变量</td><td align="center">寄存器</td></tr><tr><td align="center">打开文件</td><td align="center">堆栈</td></tr><tr><td align="center">子进程</td><td align="center">状态</td></tr><tr><td align="center">即将发生的定时器</td><td align="center"></td></tr><tr><td align="center">信号与信号处理程序</td><td align="center"></td></tr><tr><td align="center">账户信息</td><td align="center"></td></tr></tbody></table><p>和进程一样，线程可以处于下面这几种状态：运行中、阻塞、就绪和终止（进程图中没有画）。正在运行的线程拥有 CPU 时间片并且状态是运行中。一个被阻塞的线程会等待某个释放它的事件。例如，当一个线程执行从键盘读入数据的系统调用时，该线程就被阻塞直到有输入为止。线程通常会被阻塞，直到它等待某个外部事件的发生或者有其他线程来释放它。线程之间的状态转换和进程之间的状态转换是一样的。</p><p>每个线程都会有自己的堆栈，如下图所示</p><p><img src="/%E7%BC%96%E7%A8%8B%E7%B1%BB/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/multi-th-stack.png" alt="stack"></p><hr><h2 id="线程系统调用"><a href="#线程系统调用" class="headerlink" title="线程系统调用"></a>线程系统调用</h2><p>进程通常会从当前的某个单线程开始，然后这个线程通过调用一个库函数（比如 thread_create ）创建新的线程。线程创建的函数会要求指定新创建线程的名称。创建的线程通常都返回一个线程标识符，该标识符就是新线程的名字。</p><p>当一个线程完成工作后，可以通过调用一个函数（比如 thread_exit）来退出。紧接着线程消失，状态变为终止，不能再进行调度。在某些线程的运行过程中，可以通过调用函数例如 thread_join ，表示一个线程可以等待另一个线程退出。这个过程阻塞调用线程直到等待特定的线程退出。在这种情况下，线程的创建和终止非常类似于进程的创建和终止。</p><p>另一个常见的线程是调用 thread_yield，它允许线程自动放弃 CPU 从而让另一个线程运行。这样一个调用还是很重要的，因为不同于进程，线程是无法利用时钟中断强制让线程让出 CPU 的。</p><hr><h2 id="POSIX-线程"><a href="#POSIX-线程" class="headerlink" title="POSIX 线程"></a>POSIX 线程</h2><blockquote><p>POSIX线程（通常称为pthreads）是一种独立于语言而存在的执行模型，以及并行执行模型。它允许程序控制时间上重叠的多个不同的工作流程。每个工作流程都称为一个线程，可以通过调用POSIX Threads API来实现对这些流程的创建和控制。可以把它理解为线程的标准。</p></blockquote><p>POSIX Threads 的实现在许多类似且符合POSIX的操作系统上可用，例如 FreeBSD、NetBSD、OpenBSD、Linux、macOS、Android、Solaris，它在现有 Windows API 之上实现了pthread。</p><table><thead><tr><th align="left">线程调用</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">pthread_create</td><td align="left">创建一个新线程</td></tr><tr><td align="left">pthread_exit</td><td align="left">结束调用的线程</td></tr><tr><td align="left">pthread_join</td><td align="left">等待一个特定的线程退出</td></tr><tr><td align="left">pthread_yield</td><td align="left">释放 CPU 来运行另外一个线程</td></tr><tr><td align="left">pthread_attr_init</td><td align="left">创建并初始化一个线程的属性结构</td></tr><tr><td align="left">pthread_attr_destory</td><td align="left">删除一个线程的属性结构</td></tr></tbody></table><p>代码示例：</p><pre><code>#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define NUMBER_OF_THREADS 10void *print_hello_world(vvoid *tid)&#123;    /* 输出线程的标识符，然后退出 */    printf(&quot;Hello World. Greetings from thread %d\n&quot;,tid);    pthread_exit(NULL);&#125;int main(int argc,char *argv[])&#123;    /* 主程序创建 10 个线程，然后退出 */    pthread_t threads[NUMBER_OF_THREADS];    int status,i;        for(int i = 0;i &lt; NUMBER_OF_THREADS;i++)&#123;    printf(&quot;Main here. Creating thread %d\n&quot;,i);    status = pthread_create(&amp;threads[i], NULL, print_hello_world, (void *)i);        if(status != 0)&#123;        printf(&quot;Oops. pthread_create returned error code %d\n&quot;,status);        exit(-1);    &#125;    &#125;    exit(NULL);&#125;</code></pre><hr><h2 id="线程实现"><a href="#线程实现" class="headerlink" title="线程实现"></a>线程实现</h2><p>主要有三种实现方式：</p><p>在用户空间中实现线程；<br>在内核空间中实现线程；<br>在用户和内核空间中混合实现线程。</p><p>第一种方法是把整个线程包放在用户空间中，内核对线程一无所知，它不知道线程的存在。所有的这类实现都有同样的通用结构</p><p><img src="/%E7%BC%96%E7%A8%8B%E7%B1%BB/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/multi-th-in-user-process.png" alt="在用户空间中实现多线程"></p><p>线程在运行时系统之上运行，运行时系统是管理线程过程的集合，包括前面提到的四个过程： pthread_create, pthread_exit, pthread_join 和 pthread_yield。</p><blockquote><p><strong>运行时系统(Runtime System)</strong> 也叫做运行时环境，该运行时系统提供了程序在其中运行的环境。此环境可能会解决许多问题，包括应用程序内存的布局，程序如何访问变量，在过程之间传递参数的机制，与操作系统的接口等等。编译器根据特定的运行时系统进行假设以生成正确的代码。通常，运行时系统将负责设置和管理堆栈，并且会包含诸如垃圾收集，线程或语言内置的其他动态的功能。</p></blockquote><p>在用户空间管理线程时，每个进程需要有其专用的线程表(thread table)，用来跟踪该进程中的线程。这些表和内核中的进程表类似，不过它仅仅记录各个线程的属性，如每个线程的程序计数器、堆栈指针、寄存器和状态。该线程标由运行时系统统一管理。当一个线程转换到就绪状态或阻塞状态时，在该线程表中存放重新启动该线程的所有信息，与内核在进程表中存放的信息完全一样。</p><hr><h3 id="在用户空间实现线程的优势"><a href="#在用户空间实现线程的优势" class="headerlink" title="在用户空间实现线程的优势"></a>在用户空间实现线程的优势</h3><p>在用户空间中实现线程要比在内核空间中实现线程具有这些方面的优势：考虑如果在线程完成时或者是在调用 pthread_yield 时，必要时会进程线程切换，然后线程的信息会被保存在运行时环境所提供的线程表中，然后，线程调度程序来选择另外一个需要运行的线程。<strong>保存线程的状态和调度程序都是本地过程，所以启动他们比进行内核调用效率更高。因而不需要切换到内核，也就不需要上下文切换，也不需要对内存高速缓存进行刷新，因为线程调度非常便捷，因此效率比较高</strong>。</p><p>在用户空间实现线程还有一个优势就是它允许每个进程有自己定制的调度算法。例如在某些应用程序中，那些具有垃圾收集线程的应用程序（知道是谁了吧）就不用担心自己线程会不会在不合适的时候停止，这是一个优势。用户线程还具有较好的可扩展性，因为内核空间中的内核线程需要一些表空间和堆栈空间，如果内核线程数量比较大，容易造成问题。</p><hr><h3 id="在用户空间实现线程的劣势"><a href="#在用户空间实现线程的劣势" class="headerlink" title="在用户空间实现线程的劣势"></a>在用户空间实现线程的劣势</h3><p>尽管在用户空间实现线程会具有一定的性能优势，但是劣势还是很明显的，你如何实现阻塞系统调用呢？假设在还没有任何键盘输入之前，一个线程读取键盘，让线程进行系统调用是不可能的，因为这会停止所有的线程。所以，使用线程的一个目标是能够让线程进行阻塞调用，并且要避免被阻塞的线程影响其他线程。</p><p>与阻塞调用类似的问题是缺页中断问题，实际上，计算机并不会把所有的程序都一次性的放入内存中，如果某个程序发生函数调用或者跳转指令到了一条不在内存的指令上，就会发生页面故障，而操作系统将到磁盘上取回这个丢失的指令，这就称为缺页故障。而在对所需的指令进行读入和执行时，相关的进程就会被阻塞。如果只有一个线程引起页面故障，内核由于甚至不知道有线程存在，通常会吧整个进程阻塞直到磁盘 I/O 完成为止，尽管其他的线程是可以运行的。</p><p>另外一个问题是，如果一个线程开始运行，该线程所在进程中的其他线程都不能运行，除非第一个线程自愿的放弃 CPU，在一个单进程内部，没有时钟中断，所以不可能使用轮转调度的方式调度线程。除非其他线程能够以自己的意愿进入运行时环境，否则调度程序没有可以调度线程的机会。</p><hr><h3 id="在内核中实现线程"><a href="#在内核中实现线程" class="headerlink" title="在内核中实现线程"></a>在内核中实现线程</h3><p>现在我们考虑使用内核来实现线程的情况，此时不再需要运行时环境了。另外，每个进程中也没有线程表。相反，在内核中会有用来记录系统中所有线程的线程表。当某个线程希望创建一个新线程或撤销一个已有线程时，它会进行一个系统调用，这个系统调用通过对线程表的更新来完成线程创建或销毁工作。</p><p><img src="/%E7%BC%96%E7%A8%8B%E7%B1%BB/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/multi-th-in-core.png" alt="在内核中实现多线程"></p><p>内核中的线程表持有每个线程的寄存器、状态和其他信息。这些信息和用户空间中的线程信息相同，但是位置却被放在了内核中而不是用户空间中。另外，内核还维护了一张进程表用来跟踪系统状态。</p><p>所有能够阻塞的调用都会通过系统调用的方式来实现，当一个线程阻塞时，内核可以进行选择，是运行在同一个进程中的另一个线程（如果有就绪线程的话）还是运行一个另一个进程中的线程。但是在用户实现中，运行时系统始终运行自己的线程，直到内核剥夺它的 CPU 时间片（或者没有可运行的线程存在了）为止。</p><p>由于在内核中创建或者销毁线程的开销比较大，所以某些系统会采用可循环利用的方式来回收线程。当某个线程被销毁时，就把它标志为不可运行的状态，但是其内部结构没有受到影响。稍后，在必须创建一个新线程时，就会重新启用旧线程，把它标志为可用状态。</p><p>如果某个进程中的线程造成缺页故障后，内核很容易的就能检查出来是否有其他可运行的线程，如果有的话，在等待所需要的页面从磁盘读入时，就选择一个可运行的线程运行。这样做的缺点是系统调用的代价比较大，所以如果线程的操作（创建、终止）比较多，就会带来很大的开销。</p><hr><h3 id="混合实现"><a href="#混合实现" class="headerlink" title="混合实现"></a>混合实现</h3><p>结合用户空间和内核空间的优点，设计人员采用了一种内核级线程的方式，然后将用户级线程与某些或者全部内核线程多路复用起来</p><p><img src="/%E7%BC%96%E7%A8%8B%E7%B1%BB/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/multi-th-in-user-core.png" alt="用户线程与内核线程的多路复用"></p><p>在这种模型中，编程人员可以自由控制用户线程和内核线程的数量，具有很大的灵活度。采用这种方法，内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程多路复用。</p>]]></content>
      
      
      <categories>
          
          <category> 编程类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> linux </tag>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello，World!你好，世界！</title>
      <link href="/%E7%BC%96%E7%A8%8B%E7%B1%BB/hello-world/"/>
      <url>/%E7%BC%96%E7%A8%8B%E7%B1%BB/hello-world/</url>
      
        <content type="html"><![CDATA[<p>欢迎来到我的博客，在这里我会分享一些学习经历以及一些生活琐事。</p>]]></content>
      
      
      <categories>
          
          <category> 编程类 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
