{"meta":{"title":"浮萍","subtitle":"Home","description":"","author":"dannysunsan","url":"https://dannysunsan.github.io","root":"/"},"pages":[{"title":"关于我","date":"2021-11-22T06:57:20.000Z","updated":"2021-11-23T06:57:34.824Z","comments":false,"path":"about/index.html","permalink":"https://dannysunsan.github.io/about/","excerpt":"","text":"关于我从事 c\\c++ 客户端软件开发，主要开发语言 c\\c++、python，熟悉Windows和Linux操作系统； 了解MFC、多线程、多进程、http\\https、TCP\\UDP。熟悉 git TFS热爱开源项目、热爱新技术、热爱新事物。 关于工作城市：深圳 经历： 北京构力科技有限公司深圳分公司 2019-2021 C++软件开发 联影集团深圳中央研究院 2021-至今 软件开发 关于学习学如逆水行舟，不进则退… 近期学习方向：Python &amp; C# &amp; WPF &amp; 汇编 关于座右铭 The Harder You Work, The Luckier You Will Be. (越努力，越幸运) 关于爱好喜爱羽毛球、爬山、看小说、动漫。 联系我 Home: dannysunsan.github.io Email: &#56;&#x36;&#49;&#x38;&#51;&#x37;&#x31;&#x35;&#49;&#64;&#x71;&#113;&#46;&#x63;&#x6f;&#x6d; GitHub: DannySunsan WeiBo: DannySunsan"},{"title":"tags","date":"2021-11-22T06:54:58.000Z","updated":"2021-11-22T06:56:23.560Z","comments":false,"path":"tags/index.html","permalink":"https://dannysunsan.github.io/tags/","excerpt":"","text":""},{"title":"categories","date":"2021-11-22T06:56:48.000Z","updated":"2021-11-22T06:57:07.409Z","comments":false,"path":"categories/index.html","permalink":"https://dannysunsan.github.io/categories/","excerpt":"","text":""}],"posts":[{"title":"pyinstall打包方案","slug":"pyinstall打包方案","date":"2021-12-23T02:37:20.000Z","updated":"2021-12-23T05:27:56.612Z","comments":true,"path":"编程类/pyinstall打包方案/","link":"","permalink":"https://dannysunsan.github.io/%E7%BC%96%E7%A8%8B%E7%B1%BB/pyinstall%E6%89%93%E5%8C%85%E6%96%B9%E6%A1%88/","excerpt":"","text":"pyinstall打包方案简单打包安装pyinstaller pip install pyinstaller 切到需要打包的文件Target.py目录下，运行 pyinstaller [&lt;args&gt;] Target.py 常用参数用法： --distpath &lt;path&gt;: 打包到哪个目录下 -w: 指定生成 GUI 软件，也就是运行时不打开控制台 -c: 运行时打开控制台 -i &lt;Icon File&gt;: 指定打包后可执行文件的图标 --clean: 在构建之前清理PyInstaller缓存并删除临时文件 打包类型分为单个文件和文件夹： -D: 创建包含可执行文件的单文件夹包，同时会有一大堆依赖的 dll 文件，这是默认选项 -F: 只生成一个 .exe 文件，如果项目比较小的话可以用这个，但比较大的话就不推荐 运行时可能报文件丢失的错误，因为打包的时候配置文件之类的并不会一并打包过去，我们手动复制进打包目录下就行。 文件过大问题如果是在Anacanda的环境下进行打包，会把很多不相干的库也打包进来，造成文件变得很大，随随便便就是几百兆，因此，我们需要用纯净的环境进行打包，来减少那些不相干的东西。 Pipenv 是一款管理虚拟环境的命令行软件，简单来讲，它可以创建一个只在某个目录下的局部 Python 环境，而这个环境是可以和全局环境脱离开的。 首先，安装pipenv pip install pipenv 运行 pipenv install [--python 3.9.7] install后面的参数可以缺省或者指定你安装的python版本 这样虚拟环境就创建成功了，使用命令pip list可以发现里面只有很少的库。 在虚拟环境下安装pyinstaller和依赖库： pipenv install pyinstaller pipenv install [libname] 安装完成后先运行一下，如果没问题，再进行打包。 打包完毕后，发现，文件少了很多，从几百兆减少到几十兆，这样我们就打包完成了。 其它注意事项打包过程中可能会遇到没有upx的问题，可以再github上面下载下来,复制upx.exe放到pyinstaller.exe对应的文件目录下。","categories":[{"name":"编程类","slug":"编程类","permalink":"https://dannysunsan.github.io/categories/%E7%BC%96%E7%A8%8B%E7%B1%BB/"}],"tags":[{"name":"python","slug":"python","permalink":"https://dannysunsan.github.io/tags/python/"}]},{"title":"python删除目录下所有文件的方法","slug":"python删除目录下所有文件的方法","date":"2021-12-14T07:58:05.000Z","updated":"2021-12-14T08:14:12.423Z","comments":true,"path":"编程类/python删除目录下所有文件的方法/","link":"","permalink":"https://dannysunsan.github.io/%E7%BC%96%E7%A8%8B%E7%B1%BB/python%E5%88%A0%E9%99%A4%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"","text":"删除所有文件及文件夹python中没有专门用于删除文件的接口，不过实现起来也不难，我这里提供了一种一种递归的方式，先利用os.listdir(path)获取目录下的所有文件，如果是文件夹就进行递归，直到最后一级；如果是文件，修改只读为可读写，删除文件。最后利用shutil.rmtree(path)删除所有目录。 1234567891011121314151617181920import osimport shutilimport stat def delFiles(path) -&gt; bool: try: lstFiles = os.listdir(path) for file in lstFiles: full_path = os.path.join(path,file) if os.path.isdir(full_path): delFiles(full_path) else: os.chmod(full_path,stat.S_IWRITE|stat.S_IWGRP|stat.S_IWOTH) os.remove(full_path) if os.path.exists(path): shutil.rmtree(path) except Exception as err: print(err) return False return True","categories":[{"name":"编程类","slug":"编程类","permalink":"https://dannysunsan.github.io/categories/%E7%BC%96%E7%A8%8B%E7%B1%BB/"}],"tags":[{"name":"python","slug":"python","permalink":"https://dannysunsan.github.io/tags/python/"}]},{"title":"cxx并发之condition_variable","slug":"cxx并发之condition-variable","date":"2021-11-25T01:46:10.000Z","updated":"2021-11-25T06:35:58.380Z","comments":true,"path":"编程类/cxx并发之condition-variable/","link":"","permalink":"https://dannysunsan.github.io/%E7%BC%96%E7%A8%8B%E7%B1%BB/cxx%E5%B9%B6%E5%8F%91%E4%B9%8Bcondition-variable/","excerpt":"","text":"condition_variable参考 条件变量是一种能够阻塞调用线程的对象，直到通知恢复为止。 当调用它的一个等待函数时，它使用unique_lock(通过互斥锁mutex)来锁定线程。线程保持阻塞状态，直到被另一个线程唤醒，该线程调用同一个condition_variable对象上的通知函数。 类型为condition_variable的对象总是使用unique_lock&lt;mutex&gt;来等待;对于适用于任何类型的可锁定类型的替代方法，请参阅condition_variable_any。 三个wait functions， wait Wait until notified wait_for Wait for timeout or until notified wait_until Wait until notified or time point 两个notify functions, notify_one Notify one notify_all Notify all wait1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556void fff() &#123; for (int i = 0; i &lt; 5; ++i) &#123; cout &lt;&lt; this_thread::get_id() &lt;&lt; &quot; : &quot; &lt;&lt; i &lt;&lt; endl; &#125; &#125; void startProcess() &#123; mutex mu; condition_variable cdv; bool bLock = false; thread th1([&amp;] &#123; for (;;) &#123; &#123; std::unique_lock&lt;std::mutex&gt; lock(mu); cdv.wait(lock, [&amp;bLock] &#123; return bLock; &#125;); bLock = false; &#125; fff(); &#125; &#125; ); thread th2([&amp;] &#123; for (;;) &#123; &#123; std::unique_lock&lt;std::mutex&gt; lock(mu); cdv.wait(lock, [&amp;bLock] &#123; return bLock; &#125;); bLock = false; &#125; fff(); &#125; &#125; ); for(;;) &#123; &#123; std::unique_lock&lt;std::mutex&gt; lock(mu); bLock = true; &#125; Sleep(5000); cdv.notify_one(); &#125; &#125; wait_for123while (cdv.wait_for(lock, std::chrono::seconds(1)) == std::cv_status::timeout) &#123; std::cout &lt;&lt; this_thread::get_id() &lt;&lt;&#x27;.&#x27; &lt;&lt; std::endl;&#125; wait until12345xtime t;t.sec = 1;while (cdv.wait_until(lock, &amp;t) == std::cv_status::timeout) &#123; std::cout &lt;&lt; this_thread::get_id() &lt;&lt; &#x27;.&#x27; &lt;&lt; std::endl;&#125;","categories":[{"name":"编程类","slug":"编程类","permalink":"https://dannysunsan.github.io/categories/%E7%BC%96%E7%A8%8B%E7%B1%BB/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://dannysunsan.github.io/tags/c/"},{"name":"多线程","slug":"多线程","permalink":"https://dannysunsan.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"并发","slug":"并发","permalink":"https://dannysunsan.github.io/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"c++并发之<future>","slug":"c-并发之-future","date":"2021-11-24T01:52:45.000Z","updated":"2021-11-29T09:30:27.276Z","comments":true,"path":"编程类/c-并发之-future/","link":"","permalink":"https://dannysunsan.github.io/%E7%BC%96%E7%A8%8B%E7%B1%BB/c-%E5%B9%B6%E5%8F%91%E4%B9%8B-future/","excerpt":"","text":"futurestd::future 可以用来获取异步任务的结果，因此可以把它当成一种简单的线程间同步的手段。std::future 通常由某个 Provider 创建，你可以把 Provider 想象成一个异步任务的提供者，Provider 在某个线程中设置共享状态的值，与该共享状态相关联的 std::future 对象调用 get（通常在另外一个线程中） 获取该值，如果共享状态的标志不为 ready，则调用 std::future::get 会阻塞当前的调用者，直到 Provider 设置了共享状态的值（此时共享状态的标志变为 ready），std::future::get 返回异步任务的值或异常（如果发生了异常）。 &lt;future&gt;头文件包含以下几个类和函数： Providers类：std::promise，std::package_task Future类：std::future，shared_future Provides函数：std::async() 其他类型：std::future_error，std::future_errc，std::future_status，std::launch std::promisepromise 对象可以保存某一类型 T 的值，该值可被 future 对象读取（可能在另外一个线程中），因此 promise 也提供了一种线程同步的手段。在 promise 对象构造时可以和一个共享状态（通常是std::future）相关联，并可以在相关联的共享状态(std::future)上保存一个类型为 T 的值。 可以通过 get_future 来获取与该 promise 对象相关联的 future 对象，调用该函数之后，两个对象共享相同的共享状态(shared state) promise 对象是异步 Provider，它可以在某一时刻设置共享状态的值。 future 对象可以异步返回共享状态的值，或者在必要的情况下阻塞调用者并等待共享状态标志变为 ready，然后才能获取共享状态的值。 另外，std::promise 的 operator= 没有拷贝语义，即 std::promise 普通的赋值操作被禁用，operator= 只有 move 语义，所以 std::promise 对象是禁止拷贝的。 1234567891011121314151617181920212223242526272829303132333435363738394041void get_input(std::promise&lt;int&gt;&amp; pi) &#123; int x; std::cout &lt;&lt; &quot;Enter an inter va==\\n&quot;; std::cin.exceptions(std::ios::failbit); try &#123; std::cin &gt;&gt; x; pi.set_value(x); //set_value会将共享标志位置为ready &#125; catch (std::exception&amp;) &#123; pi.set_exception(std::current_exception()); &#125; &#125; void printSth(std::future&lt;int&gt;&amp; fut) &#123; try &#123; int x = fut.get();//在共享标志位置为ready之前会被阻塞 std::cout &lt;&lt; x &lt;&lt; endl; &#125; catch (std::exception&amp; e) &#123; std::cout &lt;&lt; &quot;exception&quot; &lt;&lt; e.what() &lt;&lt; endl; &#125; &#125; void startProcess() &#123; std::promise&lt;int&gt; pi; std::future&lt;int&gt; fut = pi.get_future(); std::thread th1(get_input, std::ref(pi)); std::thread th2(printSth, std::ref(fut)); th1.join(); th2.join(); &#125; std::promise::set_value_at_thread_exit 设置共享状态的值，但是只有当线程退出的时候promise对象才会置为ready std::packaged_taskstd::packaged_task 对象内部包含了两个最基本元素，一、被包装的任务(stored task)，任务(task)是一个可调用的对象，如函数指针、成员函数指针或者函数对象，二、共享状态(shared state)，用于保存任务的返回值，可以通过 std::future 对象来达到异步访问共享状态的效果。 可以通过 std::packged_task::get_future 来获取与共享状态相关联的 std::future 对象。在调用该函数之后，两个对象共享相同的共享状态，具体解释如下： std::packaged_task 对象是异步 Provider，它在某一时刻通过调用被包装的任务来设置共享状态的值。 std::future 对象是一个异步返回对象，通过它可以获得共享状态的值，当然在必要的时候需要等待共享状态标志变为 ready. std::packaged_task 的共享状态的生命周期一直持续到最后一个与之相关联的对象被释放或者销毁为止。 1234567891011121314151617181920void processWorks() &#123; std::packaged_task&lt;int(int)&gt; task([](int total) &#123; for (int i = 0; i &lt; total; ++i) &#123; Sleep(1000); cout &lt;&lt; this_thread::get_id() &lt;&lt; &quot; : &quot; &lt;&lt; i &lt;&lt; endl; &#125; return total; &#125;); std::future&lt;int&gt; fut = task.get_future(); task(3); std::cout &lt;&lt; fut.get() &lt;&lt; std::endl;//此处会等待task执行完成，并返回结果 task.reset();//重置 packaged_task 的共享状态 fut = task.get_future(); std::thread(std::move(task), 5).detach(); std::cout &lt;&lt; fut.get() &lt;&lt; std::endl;//此处会等待task执行完成，并返回结果 &#125; std::async()12345678910111213141516171819202122// a non-optimized way of checking for prime numbers:bool is_prime (int x) &#123; std::cout &lt;&lt; &quot;Calculating. Please, wait...\\n&quot;; for (int i=2; i&lt;x; ++i) if (x%i==0) return false; return true;&#125;int main ()&#123; // call is_prime(313222313) asynchronously: std::future&lt;bool&gt; fut = std::async (is_prime,313222313); std::cout &lt;&lt; &quot;Checking whether 313222313 is prime.\\n&quot;; // ... bool ret = fut.get(); // waits for is_prime to return if (ret) std::cout &lt;&lt; &quot;It is prime!\\n&quot;; else std::cout &lt;&lt; &quot;It is not prime.\\n&quot;; return 0;&#125; Exception safety exception type error condition description system_error errc::resource_unavailable_try_again The system isunable to start a new thread shared_futureshared_future对象的行为类似于future对象，不同之处在于它可以被复制，并且多个shared_future对象可以共享其共享状态的所有权。它们还允许在准备就绪后多次检索处于共享状态的值。 Shared_future对象可以从future对象隐式转换(参见其构造函数)，也可以通过调用future::share显式获取。在这两种情况下，获取它的future对象将其与共享状态的关联转移到shared_future，并使其自身失效。 共享状态的生存期至少持续到与之关联的最后一个对象被销毁为止。从shared_future(使用成员get)中检索值不会释放其对共享状态的所有权(与futures不同)。因此，如果与shared_future对象关联，共享状态可以在最初获取它的对象中保存(如果有的话)。 123456789101112void shareWorks() &#123; std::future&lt;int&gt; fut = async([] &#123; cout &lt;&lt; &quot;async\\n&quot;; return 1; &#125;); std::shared_future&lt;int&gt; sFut = fut.share(); // 共享的 future 对象可以被多次访问. std::cout &lt;&lt; sFut.get() &lt;&lt; std::endl; std::cout &lt;&lt; sFut.get() &lt;&lt; std::endl; &#125;","categories":[{"name":"编程类","slug":"编程类","permalink":"https://dannysunsan.github.io/categories/%E7%BC%96%E7%A8%8B%E7%B1%BB/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://dannysunsan.github.io/tags/c/"},{"name":"多线程","slug":"多线程","permalink":"https://dannysunsan.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"并发","slug":"并发","permalink":"https://dannysunsan.github.io/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"进程间通信","slug":"进程间通信","date":"2021-11-23T07:41:45.000Z","updated":"2021-11-26T09:32:36.901Z","comments":true,"path":"编程类/进程间通信/","link":"","permalink":"https://dannysunsan.github.io/%E7%BC%96%E7%A8%8B%E7%B1%BB/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/","excerpt":"","text":"进程间通信进程是需要频繁的和其他进程进行交流的。例如，在一个 shell 管道中，第一个进程的输出必须传递给第二个进程，这样沿着管道进行下去。因此，进程之间如果需要通信的话，必须要使用一种良好的数据结构以至于不能被中断。下面我们会一起讨论有关 进程间通信(Inter Process Communication, IPC) 的问题。 关于进程间的通信，这里有三个问题 上面提到了第一个问题，那就是一个进程如何传递消息给其他进程。 第二个问题是如何确保两个或多个线程之间不会相互干扰。例如，两个航空公司都试图为不同的顾客抢购飞机上的最后一个座位。 第三个问题是数据的先后顺序的问题，如果进程 A 产生数据并且进程 B 打印数据。则进程 B 打印数据之前需要先等 A 产生数据后才能够进行打印。 需要注意的是，这三个问题中的后面两个问题同样也适用于线程 第一个问题在线程间比较好解决，因为它们共享一个地址空间，它们具有相同的运行时环境，可以想象你在用高级语言编写多线程代码的过程中，线程通信问题是不是比较容易解决？ 另外两个问题也同样适用于线程，同样的问题可用同样的方法来解决。我们后面会慢慢讨论这三个问题，你现在脑子中大致有个印象即可。 竞态条件在一些操作系统中，协作的进程可能共享一些彼此都能读写的公共资源。公共资源可能在内存中也可能在一个共享文件。为了讲清楚进程间是如何通信的，这里我们举一个例子：一个后台打印程序。当一个进程需要打印某个文件时，它会将文件名放在一个特殊的后台目录(spooler directory)中。另一个进程 打印后台进程(printer daemon) 会定期的检查是否需要文件被打印，如果有的话，就打印并将该文件名从目录下删除。 假设我们的后台目录有非常多的 槽位(slot)，编号依次为 0，1，2，…，每个槽位存放一个文件名。同时假设有两个共享变量：out，指向下一个需要打印的文件；in，指向目录中下个空闲的槽位。可以把这两个文件保存在一个所有进程都能访问的文件中，该文件的长度为两个字。在某一时刻，0 至 3 号槽位空，4 号至 6 号槽位被占用。在同一时刻，进程 A 和 进程 B 都决定将一个文件排队打印，情况如下 墨菲法则(Murphy) 中说过，任何可能出错的地方终将出错，这句话生效时，可能发生如下情况。 进程 A 读到 in 的值为 7，将 7 存在一个局部变量 next_free_slot 中。此时发生一次时钟中断，CPU 认为进程 A 已经运行了足够长的时间，决定切换到进程 B 。进程 B 也读取 in 的值，发现是 7，然后进程 B 将 7 写入到自己的局部变量 next_free_slot 中，在这一时刻两个进程都认为下一个可用槽位是 7 。 进程 B 现在继续运行，它会将打印文件名写入到 slot 7 中，然后把 in 的指针更改为 8 ，然后进程 B 离开去做其他的事情 现在进程 A 开始恢复运行，由于进程 A 通过检查 next_free_slot也发现 slot 7 的槽位是空的，于是将打印文件名存入slot 7 中，然后把 in 的值更新为 8 ，由于 slot 7 这个槽位中已经有进程 B 写入的值，所以进程 A 的打印文件名会把进程 B 的文件覆盖，由于打印机内部是无法发现是哪个进程更新的，它的功能比较局限，所以这时候进程 B 永远无法打印输出，类似这种情况，**即两个或多个线程同时对一共享数据进行修改，从而影响程序运行的正确性时，这种就被称为竞态条件(race condition)**。调试竞态条件是一种非常困难的工作，因为绝大多数情况下程序运行良好，但在极少数的情况下会发生一些无法解释的奇怪现象。 临界区不仅共享资源会造成竞态条件，事实上共享文件、共享内存也会造成竞态条件、那么该如何避免呢？或许一句话可以概括说明：禁止一个或多个进程在同一时刻对共享资源（包括共享内存、共享文件等）进行读写。换句话说，我们需要一种 互斥(mutual exclusion) 条件，这也就是说，如果一个进程在某种方式下使用共享变量和文件的话，除该进程之外的其他进程就禁止做这种事（访问统一资源）。上面问题的纠结点在于，在进程 A 对共享变量的使用未结束之前进程 B 就使用它。在任何操作系统中，为了实现互斥操作而选用适当的原语是一个主要的设计问题，接下来我们会着重探讨一下。 避免竞争问题的条件可以用一种抽象的方式去描述。大部分时间，进程都会忙于内部计算和其他不会导致竞争条件的计算。然而，有时候进程会访问共享内存或文件，或者做一些能够导致竞态条件的操作。我们把对共享内存进行访问的程序片段称作 临界区域(critical region) 或 临界区(critical section)。如果我们能够正确的操作，使两个不同进程不可能同时处于临界区，就能避免竞争条件，这也是从操作系统设计角度来进行的。 尽管上面这种设计避免了竞争条件，但是不能确保并发线程同时访问共享数据的正确性和高效性。一个好的解决方案，应该包含下面四种条件 任何时候两个进程不能同时处于临界区 不应对 CPU 的速度和数量做任何假设 位于临界区外的进程不得阻塞其他进程 不能使任何进程无限等待进入临界区 从抽象的角度来看，我们通常希望进程的行为如上图所示，在 t1 时刻，进程 A 进入临界区，在 t2 的时刻，进程 B 尝试进入临界区，因为此时进程 A 正在处于临界区中，所以进程 B 会阻塞直到 t3 时刻进程 A 离开临界区，此时进程 B 能够允许进入临界区。最后，在 t4 时刻，进程 B 离开临界区，系统恢复到没有进程的原始状态。 忙等互斥下面我们会继续探讨实现互斥的各种设计，在这些方案中，当一个进程正忙于更新其关键区域的共享内存时，没有其他进程会进入其关键区域，也不会造成影响。 屏蔽中断在单处理器系统上，最简单的解决方案是让每个进程在进入临界区后立即屏蔽所有中断，并在离开临界区之前重新启用它们。屏蔽中断后，时钟中断也会被屏蔽。CPU 只有发生时钟中断或其他中断时才会进行进程切换。这样，在屏蔽中断后 CPU 不会切换到其他进程。所以，一旦某个进程屏蔽中断之后，它就可以检查和修改共享内存，而不用担心其他进程介入访问共享数据。 这个方案可行吗？进程进入临界区域是由谁决定的呢？不是用户进程吗？当进程进入临界区域后，用户进程关闭中断，如果经过一段较长时间后进程没有离开，那么中断不就一直启用不了，结果会如何？可能会造成整个系统的终止。而且如果是多处理器的话，屏蔽中断仅仅对执行 disable 指令的 CPU 有效。其他 CPU 仍将继续运行，并可以访问共享内存。 另一方面，对内核来说，当它在执行更新变量或列表的几条指令期间将中断屏蔽是很方便的。例如，如果多个进程处理就绪列表中的时候发生中断，则可能会发生竞态条件的出现。所以，屏蔽中断对于操作系统本身来说是一项很有用的技术，但是对于用户线程来说，屏蔽中断却不是一项通用的互斥机制。 锁变量作为第二种尝试，可以寻找一种软件层面解决方案。考虑有单个共享的（锁）变量，初始为值为 0 。当一个线程想要进入关键区域时，它首先会查看锁的值是否为 0 ，如果锁的值是 0 ，进程会把它设置为 1 并让进程进入关键区域。如果锁的状态是 1，进程会等待直到锁变量的值变为 0 。因此，锁变量的值是 0 则意味着没有线程进入关键区域。如果是 1 则意味着有进程在关键区域内。我们对上图修改后，如下所示 这种设计方式是否正确呢？是否存在纰漏呢？假设一个进程读出锁变量的值并发现它为 0 ，而恰好在它将其设置为 1 之前，另一个进程调度运行，读出锁的变量为0 ，并将锁的变量设置为 1 。然后第一个线程运行，把锁变量的值再次设置为 1，此时，临界区域就会有两个进程在同时运行。 也许有的读者可以这么认为，在进入前检查一次，在要离开的关键区域再检查一次不就解决了吗？实际上这种情况也是于事无补，因为在第二次检查期间其他线程仍有可能修改锁变量的值，换句话说，这种 set-before-check 不是一种 原子性 操作，所以同样还会发生竞争条件。 严格轮询法第三种互斥的方式先抛出来一段代码，这里的程序是用 C 语言编写，之所以采用 C 是因为操作系统普遍是用 C 来编写的（偶尔会用 C++），而基本不会使用 Java 、Modula3 或 Pascal 这样的语言，Java 中的 native 关键字底层也是 C 或 C++ 编写的源码。对于编写操作系统而言，需要使用 C 语言这种强大、高效、可预知和有特性的语言，而对于 Java ，它是不可预知的，因为它在关键时刻会用完存储器，而在不合适的时候会调用垃圾回收机制回收内存。在 C 语言中，这种情况不会发生，C 语言中不会主动调用垃圾回收回收内存。 进程 0 的代码123456789while(TRUE)&#123; while(turn != 0)&#123; /* 进入关键区域 */ critical_region(); turn = 1; /* 离开关键区域 */ noncritical_region(); &#125;&#125; 进程 1 的代码1234567while(TRUE)&#123; while(turn != 1)&#123; critical_region(); turn = 0; noncritical_region(); &#125;&#125; 在上面代码中，变量 turn，初始值为 0 ，用于记录轮到那个进程进入临界区，并检查或更新共享内存。开始时，进程 0 检查 turn，发现其值为 0 ，于是进入临界区。进程 1 也发现其值为 0 ，所以在一个等待循环中不停的测试 turn，看其值何时变为 1。连续检查一个变量直到某个值出现为止，这种方法称为 忙等待(busywaiting)。由于这种方式浪费 CPU 时间，所以这种方式通常应该要避免。只有在有理由认为等待时间是非常短的情况下，才能够使用忙等待。用于忙等待的锁，称为 自旋锁(spinlock)。 进程 0 离开临界区时，它将 turn 的值设置为 1，以便允许进程 1 进入其临界区。假设进程 1 很快便离开了临界区，则此时两个进程都处于临界区之外，turn 的值又被设置为 0 。现在进程 0 很快就执行完了整个循环，它退出临界区，并将 turn 的值设置为 1。此时，turn 的值为 1，两个进程都在其临界区外执行。 突然，进程 0 结束了非临界区的操作并返回到循环的开始。但是，这时它不能进入临界区，因为 turn 的当前值为 1，此时进程 1 还忙于非临界区的操作，进程 0 只能继续 while 循环，直到进程 1 把 turn 的值改为 0 。这说明，在一个进程比另一个进程执行速度慢了很多的情况下，轮流进入临界区并不是一个好的方法。 这种情况违反了前面的叙述 3 ，即 位于临界区外的进程不得阻塞其他进程，进程 0 被一个临界区外的进程阻塞。由于违反了第三条，所以也不能作为一个好的方案。 Peterson 解法荷兰数学家 T.Dekker 通过将锁变量与警告变量相结合，最早提出了一个不需要严格轮换的软件互斥算法 后来， G.L.Peterson 发现了一种简单很多的互斥算法，它的算法如下 1234567891011121314151617181920212223242526272829303132333435#define FALSE 0#define TRUE 1/* 进程数量 */#define N 2 /* 现在轮到谁 */int turn; /* 所有值初始化为 0 (FALSE) */int interested[N]; /* 进程是 0 或 1 */void enter_region(int process)&#123; /* 另一个进程号 */ int other; /* 另一个进程 */ other = 1 - process; /* 表示愿意进入临界区 */ interested[process] = TRUE; turn = process; /* 空循环 */ while(turn == process &amp;&amp; interested[other] == true)&#123;&#125; &#125;void leave_region(int process)&#123; /* 表示离开临界区 */ interested[process] == FALSE; &#125; 在使用共享变量时（即进入其临界区）之前，各个进程使用各自的进程号 0 或 1 作为参数来调用 enter_region，这个函数调用在需要时将使进程等待，直到能够安全的临界区。在完成对共享变量的操作之后，进程将调用 leave_region 表示操作完成，并且允许其他进程进入。 现在来看看这个办法是如何工作的。一开始，没有任何进程处于临界区中，现在进程 0 调用 enter_region。它通过设置数组元素和将 turn 置为 0 来表示它希望进入临界区。由于进程 1 并不想进入临界区，所以 enter_region 很快便返回。如果进程现在调用 enter_region，进程 1 将在此处挂起直到 interested[0] 变为 FALSE，这种情况只有在进程 0 调用 leave_region 退出临界区时才会发生。 那么上面讨论的是顺序进入的情况，现在来考虑一种两个进程同时调用 enter_region 的情况。它们都将自己的进程存入 turn，但只有最后保存进去的进程号才有效，前一个进程的进程号因为重写而丢失。假如进程 1 是最后存入的，则 turn 为 1 。当两个进程都运行到 while 的时候，进程 0 将不会循环并进入临界区，而进程 1 将会无限循环且不会进入临界区，直到进程 0 退出位置。 TSL 指令现在来看一种需要硬件帮助的方案。一些计算机，特别是那些设计为多处理器的计算机，都会有下面这条指令 TSL RX,LOCK 称为 测试并加锁(test and set lock)，它将一个内存字 lock 读到寄存器 RX 中，然后在该内存地址上存储一个非零值。读写指令能保证是一体的，不可分割的，一同执行的。在这个指令结束之前其他处理器均不允许访问内存。执行 TSL 指令的 CPU 将会锁住内存总线，用来禁止其他 CPU 在这个指令结束之前访问内存。 很重要的一点是锁住内存总线和禁用中断不一样。禁用中断并不能保证一个处理器在读写操作之间另一个处理器对内存的读写。也就是说，在处理器 1 上屏蔽中断对处理器 2 没有影响。让处理器 2 远离内存直到处理器 1 完成读写的最好的方式就是锁住总线。这需要一个特殊的硬件（基本上，一根总线就可以确保总线由锁住它的处理器使用，而其他的处理器不能使用） 为了使用 TSL 指令，要使用一个共享变量 lock 来协调对共享内存的访问。当 lock 为 0 时，任何进程都可以使用 TSL 指令将其设置为 1，并读写共享内存。当操作结束时，进程使用 move 指令将 lock 的值重新设置为 0 。 这条指令如何防止两个进程同时进入临界区呢？下面是解决方案 12345678910111213141516enter_region: | 复制锁到寄存器并将锁设为1 TSL REGISTER,LOCK | 锁是 0 吗？ CMP REGISTER,#0 | 若不是零，说明锁已被设置，所以循环 JNE enter_region | 返回调用者，进入临界区 RET leave_region: | 在锁中存入 0 MOVE LOCK,#0 | 返回调用者 RET 我们可以看到这个解决方案的思想和 Peterson 的思想很相似。假设存在如下共 4 指令的汇编语言程序。第一条指令将 lock 原来的值复制到寄存器中并将 lock 设置为 1 ，随后这个原来的值和 0 做对比。如果它不是零，说明之前已经被加过锁，则程序返回到开始并再次测试。经过一段时间后（可长可短），该值变为 0 （当前处于临界区中的进程退出临界区时），于是过程返回，此时已加锁。要清除这个锁也比较简单，程序只需要将 0 存入 lock 即可，不需要特殊的同步指令。 现在有了一种很明确的做法，那就是进程在进入临界区之前会先调用 enter_region，判断是否进行循环，如果lock 的值是 1 ，进行无限循环，如果 lock 是 0，不进入循环并进入临界区。在进程从临界区返回时它调用 leave_region，这会把 lock 设置为 0 。与基于临界区问题的所有解法一样，进程必须在正确的时间调用 enter_region 和 leave_region ，解法才能奏效。 还有一个可以替换 TSL 的指令是 XCHG，它原子性的交换了两个位置的内容，例如，一个寄存器与一个内存字，代码如下 1234567891011121314151617enter_region: | 把 1 放在内存器中 MOVE REGISTER,#1 | 交换寄存器和锁变量的内容 XCHG REGISTER,LOCK | 锁是 0 吗？ CMP REGISTER,#0 | 若不是 0 ，锁已被设置，进行循环 JNE enter_region | 返回调用者，进入临界区 RET leave_region: | 在锁中存入 0 MOVE LOCK,#0 | 返回调用者 RET XCHG 的本质上与 TSL 的解决办法一样。所有的 Intel x86 CPU 在底层同步中使用 XCHG 指令。 睡眠与唤醒上面解法中的 Peterson 、TSL 和 XCHG 解法都是正确的，但是它们都有忙等待的缺点。这些解法的本质上都是一样的，先检查是否能够进入临界区，若不允许，则该进程将原地等待，直到允许为止。 这种方式不但浪费了 CPU 时间，而且还可能引起意想不到的结果。考虑一台计算机上有两个进程，这两个进程具有不同的优先级，H 是属于优先级比较高的进程，L 是属于优先级比较低的进程。进程调度的规则是不论何时只要 H 进程处于就绪态 H 就开始运行。在某一时刻，L 处于临界区中，此时 H 变为就绪态，准备运行（例如，一条 I/O 操作结束）。现在 H 要开始忙等，但由于当 H 就绪时 L 就不会被调度，L 从来不会有机会离开关键区域，所以 H 会变成死循环，有时将这种情况称为优先级反转问题(priority inversion problem)。 现在让我们看一下进程间的通信原语，这些原语在不允许它们进入关键区域之前会阻塞而不是浪费 CPU 时间，最简单的是 sleep 和 wakeup。Sleep 是一个能够造成调用者阻塞的系统调用，也就是说，这个系统调用会暂停直到其他进程唤醒它。wakeup 调用有一个参数，即要唤醒的进程。还有一种方式是 wakeup 和 sleep 都有一个参数，即 sleep 和 wakeup 需要匹配的内存地址。 生产者-消费者问题作为这些私有原语的例子，让我们考虑生产者-消费者(producer-consumer) 问题，也称作 有界缓冲区(bounded-buffer) 问题。两个进程共享一个公共的固定大小的缓冲区。其中一个是生产者(producer)，将信息放入缓冲区， 另一个是消费者(consumer) ，会从缓冲区中取出。也可以把这个问题一般化为 m 个生产者和 n 个消费者的问题，但是我们这里只讨论一个生产者和一个消费者的情况，这样可以简化实现方案。 如果缓冲队列已满，那么当生产者仍想要将数据写入缓冲区的时候，会出现问题。它的解决办法是让生产者睡眠，也就是阻塞生产者。等到消费者从缓冲区中取出一个或多个数据项时再唤醒它。同样的，当消费者试图从缓冲区中取数据，但是发现缓冲区为空时，消费者也会睡眠，阻塞。直到生产者向其中放入一个新的数据。 这个逻辑听起来比较简单，而且这种方式也需要一种称作 监听 的变量，这个变量用于监视缓冲区的数据，我们暂定为 count，如果缓冲区最多存放 N 个数据项，生产者会每次判断 count 是否达到 N，否则生产者向缓冲区放入一个数据项并增量 count 的值。消费者的逻辑也很相似：首先测试 count 的值是否为 0 ，如果为 0 则消费者睡眠、阻塞，否则会从缓冲区取出数据并使 count 数量递减。每个进程也会检查检查是否其他线程是否应该被唤醒，如果应该被唤醒，那么就唤醒该线程。下面是生产者消费者的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/* 缓冲区 slot 槽的数量 */#define N 100 /* 缓冲区数据的数量 */int count = 0 // 生产者void producer(void)&#123; int item; /* 无限循环 */ while(TRUE)&#123; /* 生成下一项数据 */ item = produce_item() /* 如果缓存区是满的，就会阻塞 */ if(count == N)&#123; sleep(); &#125; /* 把当前数据放在缓冲区中 */ insert_item(item); /* 增加缓冲区 count 的数量 */ count = count + 1; if(count == 1)&#123; /* 缓冲区是否为空？ */ wakeup(consumer); &#125; &#125;&#125;// 消费者void consumer(void)&#123; int item; /* 无限循环 */ while(TRUE)&#123; /* 如果缓冲区是空的，就会进行阻塞 */ if(count == 0)&#123; sleep(); &#125; /* 从缓冲区中取出一个数据 */ item = remove_item(); /* 将缓冲区的 count 数量减一 */ count = count - 1 /* 缓冲区满嘛？ */ if(count == N - 1)&#123; wakeup(producer); &#125; /* 打印数据项 */ consumer_item(item); &#125;&#125; 为了在 C 语言中描述像是 sleep 和 wakeup 的系统调用，我们将以库函数调用的形式来表示。它们不是 C 标准库的一部分，但可以在实际具有这些系统调用的任何系统上使用。代码中未实现的 insert_item 和 remove_item 用来记录将数据项放入缓冲区和从缓冲区取出数据等。 现在让我们回到生产者-消费者问题上来，上面代码中会产生竞争条件，因为 count 这个变量是暴露在大众视野下的。有可能出现下面这种情况：缓冲区为空，此时消费者刚好读取 count 的值发现它为 0 。此时调度程序决定暂停消费者并启动运行生产者。生产者生产了一条数据并把它放在缓冲区中，然后增加 count 的值，并注意到它的值是 1 。由于 count 为 0，消费者必须处于睡眠状态，因此生产者调用 wakeup 来唤醒消费者。但是，消费者此时在逻辑上并没有睡眠，所以 wakeup 信号会丢失。当消费者下次启动后，它会查看之前读取的 count 值，发现它的值是 0 ，然后在此进行睡眠。不久之后生产者会填满整个缓冲区，在这之后会阻塞，这样一来两个进程将永远睡眠下去。 引起上面问题的本质是 唤醒尚未进行睡眠状态的进程会导致唤醒丢失。如果它没有丢失，则一切都很正常。一种快速解决上面问题的方式是增加一个唤醒等待位(wakeup waiting bit)。当一个 wakeup 信号发送给仍在清醒的进程后，该位置为 1 。之后，当进程尝试睡眠的时候，如果唤醒等待位为 1 ，则该位清除，而进程仍然保持清醒。 然而，当进程数量有许多的时候，这时你可以说通过增加唤醒等待位的数量来唤醒等待位，于是就有了 2、4、6、8 个唤醒等待位，但是并没有从根本上解决问题。","categories":[{"name":"编程类","slug":"编程类","permalink":"https://dannysunsan.github.io/categories/%E7%BC%96%E7%A8%8B%E7%B1%BB/"}],"tags":[{"name":"多进程","slug":"多进程","permalink":"https://dannysunsan.github.io/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"},{"name":"IPC","slug":"IPC","permalink":"https://dannysunsan.github.io/tags/IPC/"}]},{"title":"Markdown技巧","slug":"Markdown技巧","date":"2021-11-23T02:58:18.000Z","updated":"2021-11-24T06:29:34.353Z","comments":true,"path":"Markdown/Markdown技巧/","link":"","permalink":"https://dannysunsan.github.io/Markdown/Markdown%E6%8A%80%E5%B7%A7/","excerpt":"","text":"标题===== 一级标题 ============== 二级标题 ————- # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 段落换行是使用两个以上空格加上回车。 或者空一行 字体*斜体文本* _斜体文本_ **粗体文本** __粗体文本__ ***粗斜体文本*** ___粗斜体文本___ 分隔线你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： *** * * * - - - 删除线如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下： ~~文本~~ 文本 下划线下划线可以通过 HTML 的 &lt;u&gt;标签来实现： &lt;u&gt;带下划线文本&lt;/u&gt; 带下划线文本 脚注脚注是对文本的补充说明。 Markdown 脚注的格式如下: [^要注明的文本] 加油吧，骚年！^Danny。 字体博客同名的文件夹 Markdown 支持有序列表和无序列表。无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容： * 第一项 * 第二项 * 第三项 + 第一项 + 第二项 + 第三项 - 第一项 - 第二项 - 第三项 有序列表使用数字并加上 . 号来表示，如： 1. 第一项 2. 第二项 3. 第三项 列表嵌套列表嵌套只需在子列表中的选项前面添加四个空格即可： 1. 第一项： - 第一项嵌套的第一个元素 - 第一项嵌套的第二个元素 2. 第二项： - 第二项嵌套的第一个元素 - 第二项嵌套的第二个元素 Markdown 区块Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号： buzzwordopen sourcehalo 另外区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推： 最外层 第一层嵌套 第二层嵌套 区块中使用列表区块中使用列表实例如下： &gt; 区块中使用列表 &gt; 1. 第一项 &gt; 2. 第二项 &gt; + 第一项 &gt; + 第二项 &gt; + 第三项 列表中使用区块如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进。 列表中使用区块实例如下： * 第一项 &gt; buzzword &gt; halo * 第二项 Markdown 代码如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`），例如： printf() 函数 代码区块代码区块使用 4 个空格或者一个制表符（Tab 键）。 print(&#39;hello world!&#39;) 你也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）： 123$(document).ready(function () &#123; alert(&#x27;RUNOOB&#x27;);&#125;); Markdown 链接链接使用方法如下： [链接名称](链接地址) 或者 &lt;链接地址&gt; 例如： 这是一个链接 [百度](https://www.baidu.com) 这是一个链接 百度 直接使用链接地址： &lt;https://www.baidu.com&gt; https://www.baidu.com 高级链接我们可以通过变量来设置一个链接，变量赋值在文档末尾进行： 这个链接用 1 作为网址变量 [baidu][1] 然后在文档的结尾为变量赋值（网址） Markdown 图片Markdown 图片语法格式如下： 开头一个感叹号 !接着一个方括号，里面放上图片的替代文字接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。使用实例： ![百度 logo][2] Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签。 &lt;img src=&quot;https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png&quot; width=&quot;50%&quot;&gt; [1]: http://www.baidu.com/ [2]: https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png Markdown 表格Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。 语法格式如下： | 左对齐 | 居中 | 右对齐 | | :---- | :----: | ----: | | 单元格 | 单元格 | 单元格 | | 单元格 | 单元格 | 单元格 | 表头 表头 单元格 单元格 单元格 单元格 Markdown 高级技巧支持的 HTML 元素 不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。 目前支持的 HTML 元素有： &lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等 ， 如： &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 使用 Ctrl+Alt+Del 重启电脑 转义Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符： **文本加粗** \\*\\* 正常显示星号 \\*\\* Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： \\ 反斜线 ` 反引号 * 星号 _ 下划线 &#123;&#125; 花括号 [] 方括号 () 小括号 # 井字号 + 加号 - 减号 . 英文句点 ! 感叹号 公式当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如： $$\\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix}\\mathbf{i} &amp; \\mathbf{j} &amp; \\mathbf{k} \\\\frac{\\partial X}{\\partial u} &amp; \\frac{\\partial Y}{\\partial u} &amp; 0 \\\\frac{\\partial X}{\\partial v} &amp; \\frac{\\partial Y}{\\partial v} &amp; 0 \\\\end{vmatrix}{\\style{visibility:hidden}{(x+1)(x+1)}}$$$$\\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix}\\mathbf{i} &amp; \\mathbf{j} &amp; \\mathbf{k} \\\\frac{\\partial X}{\\partial u} &amp; \\frac{\\partial Y}{\\partial u} &amp; 0 \\\\frac{\\partial X}{\\partial v} &amp; \\frac{\\partial Y}{\\partial v} &amp; 0 \\\\end{vmatrix}{\\style{visibility:hidden}{(x+1)(x+1)}}$$ 1、横向流程图源码格式：123456graph LRA[方形] --&gt;B(圆角) B --&gt; C&#123;条件a&#125; C --&gt;|a=1| D[结果1] C --&gt;|a=2| E[结果2] F[横向流程图] 123456graph LR A[方形] --&gt;B(圆角) B --&gt; C&#123;条件a&#125; C --&gt;|a=1| D[结果1] C --&gt;|a=2| E[结果2] F[横向流程图] 2、竖向流程图源码格式：123456graph TDA[方形] --&gt; B(圆角) B --&gt; C&#123;条件a&#125; C --&gt; |a=1| D[结果1] C --&gt; |a=2| E[结果2] F[竖向流程图] 3、标准流程图源码格式：123456789st=&gt;start: 开始框 op=&gt;operation: 处理框 cond=&gt;condition: 判断框(是或否?) sub1=&gt;subroutine: 子流程io=&gt;inputoutput: 输入输出框e=&gt;end: 结束框st-&gt;op-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;sub1(right)-&gt;op 4、标准流程图源码格式（横向）：123456789st=&gt;start: 开始框op=&gt;operation: 处理框cond=&gt;condition: 判断框(是或否?)sub1=&gt;subroutine: 子流程io=&gt;inputoutput: 输入输出框e=&gt;end: 结束框st(right)-&gt;op(right)-&gt;condcond(yes)-&gt;io(bottom)-&gt;econd(no)-&gt;sub1(right)-&gt;op 5、UML时序图源码样例：12345对象A-&gt;对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B--&gt;对象A: 我很好(响应)对象A-&gt;对象B: 你真的好吗？ 6、UML时序图源码复杂样例：1234567891011Title: 标题：复杂使用对象A-&gt;对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B--&gt;对象A: 我很好(响应)对象B-&gt;小三: 你好吗小三--&gt;&gt;对象A: 对象B找我了对象A-&gt;对象B: 你真的好吗？Note over 小三,对象B: 我们是朋友participant CNote right of C: 没人陪我玩 7、UML标准时序图样例：123456789101112%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头 sequenceDiagram participant 张三 participant 李四 张三-&gt;王五: 王五你好吗？ loop 健康检查 王五-&gt;王五: 与疾病战斗 end Note right of 王五: 合理 食物 &lt;br/&gt;看医生... 李四--&gt;&gt;张三: 很好! 王五-&gt;李四: 你怎么样? 李四--&gt;王五: 很好! 8、甘特图样例：123456789101112131415161718192021```mermaid%% 语法示例 gantt dateFormat YYYY-MM-DD title 软件开发甘特图 section 设计 需求 :done, des1, 2014-01-06,2014-01-08 原型 :active, des2, 2014-01-09, 3d UI设计 : des3, after des2, 5d 未来任务 : des4, after des3, 5d section 开发 学习准备理解需求 :crit, done, 2014-01-06,24h 设计框架 :crit, done, after des2, 2d 开发 :crit, active, 3d 未来任务 :crit, 5d 耍 :2d section 测试 功能测试 :active, a1, after des3, 3d 压力测试 :after a1 , 20h 测试报告 : 48h```","categories":[{"name":"Markdown","slug":"Markdown","permalink":"https://dannysunsan.github.io/categories/Markdown/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://dannysunsan.github.io/tags/Markdown/"}]},{"title":"hexo常见问题","slug":"hexo常见问题","date":"2021-11-22T08:46:16.000Z","updated":"2021-11-23T09:36:49.184Z","comments":true,"path":"hexo/hexo常见问题/","link":"","permalink":"https://dannysunsan.github.io/hexo/hexo%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","excerpt":"","text":"1. 安装1.安装Git2.安装Node.js3.安装Hexo npm install -g hexo-cli hexo init myblog 2. 配置url: https://dannysunsan.github.io/ permalink: :category/:title/ pretty_urls: trailing_index: false # Set to false to remove trailing &#39;index.html&#39; from permalinks trailing_html: false # Set to false to remove trailing &#39;.html&#39; from permalinks default_category: bin post_asset_folder: true theme: miho deploy: type: git repository: https://github.com/DannySunsan/DannySunsan.github.io.git branch: gh-pages 3. 部署hexo clean //清除生成，每次重新部署前需要执行 hexo g //生成 hexo d //执行 4. 写作tags &amp; categorieshexo new page tags 修改tags/index.md 里面的内容为 --- title: 文章标签 date: 2021-11-22 14:56:48 type: &quot;tags&quot; --- hexo new page categories 修改categories/index.md 里面的内容为 --- title: 文章分类 date: 2021-11-22 14:56:48 type: &quot;categories&quot; --- hexo new page about 修改about/index.md 里面的内容为 --- title: 关于 date: 2021-11-22 14:56:48 type: &quot;categories&quot; --- hexo new newpapername 内插图片1.将Hexo目录下的配置文件_config.yml里的psot_asset_folder:设置为true。 2.在Hexo目录下执行: npm install https://github.com/CodeFalling/hexo-asset-image下面的命令有bug npm install hexo-asset-image –save 3.执行hexo n “博客名”生成博客，此时在_post目录会生成与 博客同名的文件夹。 4.将博客需要使用的图片移动到博客同名的文件夹中，然后在博客中使用Markdown的格式引用 ![图片描述文字](图片名.jpg) 主题官网","categories":[{"name":"hexo","slug":"hexo","permalink":"https://dannysunsan.github.io/categories/hexo/"}],"tags":[]},{"title":"多线程总结","slug":"多线程总结","date":"2021-11-22T07:49:09.000Z","updated":"2021-11-29T09:24:49.008Z","comments":true,"path":"编程类/多线程总结/","link":"","permalink":"https://dannysunsan.github.io/%E7%BC%96%E7%A8%8B%E7%B1%BB/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/","excerpt":"","text":"经典的线程模型理解进程的另一个角度是，用某种方法把相关的资源集中在一起。进程有存放程序正文和数据以及其他资源的地址空间。这些资源包括打开的文件、子进程、即将发生的定时器、信号处理程序、账号信息等。把这些信息放在进程中会比较容易管理。 另一个概念是，进程中拥有一个执行的线程，通常简写为 线程(thread)。线程会有程序计数器，用来记录接着要执行哪一条指令；线程还拥有寄存器，用来保存线程当前正在使用的变量；线程还会有堆栈，用来记录程序的执行路径。尽管线程必须在某个进程中执行，但是进程和线程完完全全是两个不同的概念，并且他们可以分开处理。进程用于把资源集中在一起，而线程则是 CPU 上调度执行的实体。 线程给进程模型增加了一项内容，即在同一个进程中，允许彼此之间有较大的独立性且互不干扰。在一个进程中并行运行多个线程类似于在一台计算机上运行多个进程。在多个线程中，各个线程共享同一地址空间和其他资源。在多个进程中，进程共享物理内存、磁盘、打印机和其他资源。因为线程会包含有一些进程的属性，所以线程被称为轻量的进程(lightweight processes)。多线程(multithreading)一词还用于描述在同一进程中多个线程的情况。 下图我们可以看到三个传统的进程，每个进程有自己的地址空间和单个控制线程。每个线程都在不同的地址空间中运行。 下图中，我们可以看到有一个进程三个线程的情况。每个线程都在相同的地址空间中运行。 线程不像是进程那样具备较强的独立性。同一个进程中的所有线程都会有完全一样的地址空间，这意味着它们也共享同样的全局变量。由于每个线程都可以访问进程地址空间内每个内存地址，因此一个线程可以读取、写入甚至擦除另一个线程的堆栈。线程之间除了共享同一内存空间外，还具有如下不同的内容 每个进程中的内容 每个线程中的内容 地址空间 程序计数器 全局变量 寄存器 打开文件 堆栈 子进程 状态 即将发生的定时器 信号与信号处理程序 账户信息 和进程一样，线程可以处于下面这几种状态：运行中、阻塞、就绪和终止（进程图中没有画）。正在运行的线程拥有 CPU 时间片并且状态是运行中。一个被阻塞的线程会等待某个释放它的事件。例如，当一个线程执行从键盘读入数据的系统调用时，该线程就被阻塞直到有输入为止。线程通常会被阻塞，直到它等待某个外部事件的发生或者有其他线程来释放它。线程之间的状态转换和进程之间的状态转换是一样的。 每个线程都会有自己的堆栈，如下图所示 线程系统调用进程通常会从当前的某个单线程开始，然后这个线程通过调用一个库函数（比如 thread_create ）创建新的线程。线程创建的函数会要求指定新创建线程的名称。创建的线程通常都返回一个线程标识符，该标识符就是新线程的名字。 当一个线程完成工作后，可以通过调用一个函数（比如 thread_exit）来退出。紧接着线程消失，状态变为终止，不能再进行调度。在某些线程的运行过程中，可以通过调用函数例如 thread_join ，表示一个线程可以等待另一个线程退出。这个过程阻塞调用线程直到等待特定的线程退出。在这种情况下，线程的创建和终止非常类似于进程的创建和终止。 另一个常见的线程是调用 thread_yield，它允许线程自动放弃 CPU 从而让另一个线程运行。这样一个调用还是很重要的，因为不同于进程，线程是无法利用时钟中断强制让线程让出 CPU 的。 POSIX 线程 POSIX线程（通常称为pthreads）是一种独立于语言而存在的执行模型，以及并行执行模型。它允许程序控制时间上重叠的多个不同的工作流程。每个工作流程都称为一个线程，可以通过调用POSIX Threads API来实现对这些流程的创建和控制。可以把它理解为线程的标准。 POSIX Threads 的实现在许多类似且符合POSIX的操作系统上可用，例如 FreeBSD、NetBSD、OpenBSD、Linux、macOS、Android、Solaris，它在现有 Windows API 之上实现了pthread。 线程调用 描述 pthread_create 创建一个新线程 pthread_exit 结束调用的线程 pthread_join 等待一个特定的线程退出 pthread_yield 释放 CPU 来运行另外一个线程 pthread_attr_init 创建并初始化一个线程的属性结构 pthread_attr_destory 删除一个线程的属性结构 代码示例： #include &lt;pthread.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define NUMBER_OF_THREADS 10 void *print_hello_world(vvoid *tid)&#123; /* 输出线程的标识符，然后退出 */ printf(&quot;Hello World. Greetings from thread %d\\n&quot;,tid); pthread_exit(NULL); &#125; int main(int argc,char *argv[])&#123; /* 主程序创建 10 个线程，然后退出 */ pthread_t threads[NUMBER_OF_THREADS]; int status,i; for(int i = 0;i &lt; NUMBER_OF_THREADS;i++)&#123; printf(&quot;Main here. Creating thread %d\\n&quot;,i); status = pthread_create(&amp;threads[i], NULL, print_hello_world, (void *)i); if(status != 0)&#123; printf(&quot;Oops. pthread_create returned error code %d\\n&quot;,status); exit(-1); &#125; &#125; exit(NULL); &#125; 线程实现主要有三种实现方式： 在用户空间中实现线程；在内核空间中实现线程；在用户和内核空间中混合实现线程。 第一种方法是把整个线程包放在用户空间中，内核对线程一无所知，它不知道线程的存在。所有的这类实现都有同样的通用结构 线程在运行时系统之上运行，运行时系统是管理线程过程的集合，包括前面提到的四个过程： pthread_create, pthread_exit, pthread_join 和 pthread_yield。 运行时系统(Runtime System) 也叫做运行时环境，该运行时系统提供了程序在其中运行的环境。此环境可能会解决许多问题，包括应用程序内存的布局，程序如何访问变量，在过程之间传递参数的机制，与操作系统的接口等等。编译器根据特定的运行时系统进行假设以生成正确的代码。通常，运行时系统将负责设置和管理堆栈，并且会包含诸如垃圾收集，线程或语言内置的其他动态的功能。 在用户空间管理线程时，每个进程需要有其专用的线程表(thread table)，用来跟踪该进程中的线程。这些表和内核中的进程表类似，不过它仅仅记录各个线程的属性，如每个线程的程序计数器、堆栈指针、寄存器和状态。该线程标由运行时系统统一管理。当一个线程转换到就绪状态或阻塞状态时，在该线程表中存放重新启动该线程的所有信息，与内核在进程表中存放的信息完全一样。 在用户空间实现线程的优势在用户空间中实现线程要比在内核空间中实现线程具有这些方面的优势：考虑如果在线程完成时或者是在调用 pthread_yield 时，必要时会进程线程切换，然后线程的信息会被保存在运行时环境所提供的线程表中，然后，线程调度程序来选择另外一个需要运行的线程。保存线程的状态和调度程序都是本地过程，所以启动他们比进行内核调用效率更高。因而不需要切换到内核，也就不需要上下文切换，也不需要对内存高速缓存进行刷新，因为线程调度非常便捷，因此效率比较高。 在用户空间实现线程还有一个优势就是它允许每个进程有自己定制的调度算法。例如在某些应用程序中，那些具有垃圾收集线程的应用程序（知道是谁了吧）就不用担心自己线程会不会在不合适的时候停止，这是一个优势。用户线程还具有较好的可扩展性，因为内核空间中的内核线程需要一些表空间和堆栈空间，如果内核线程数量比较大，容易造成问题。 在用户空间实现线程的劣势尽管在用户空间实现线程会具有一定的性能优势，但是劣势还是很明显的，你如何实现阻塞系统调用呢？假设在还没有任何键盘输入之前，一个线程读取键盘，让线程进行系统调用是不可能的，因为这会停止所有的线程。所以，使用线程的一个目标是能够让线程进行阻塞调用，并且要避免被阻塞的线程影响其他线程。 与阻塞调用类似的问题是缺页中断问题，实际上，计算机并不会把所有的程序都一次性的放入内存中，如果某个程序发生函数调用或者跳转指令到了一条不在内存的指令上，就会发生页面故障，而操作系统将到磁盘上取回这个丢失的指令，这就称为缺页故障。而在对所需的指令进行读入和执行时，相关的进程就会被阻塞。如果只有一个线程引起页面故障，内核由于甚至不知道有线程存在，通常会吧整个进程阻塞直到磁盘 I/O 完成为止，尽管其他的线程是可以运行的。 另外一个问题是，如果一个线程开始运行，该线程所在进程中的其他线程都不能运行，除非第一个线程自愿的放弃 CPU，在一个单进程内部，没有时钟中断，所以不可能使用轮转调度的方式调度线程。除非其他线程能够以自己的意愿进入运行时环境，否则调度程序没有可以调度线程的机会。 在内核中实现线程现在我们考虑使用内核来实现线程的情况，此时不再需要运行时环境了。另外，每个进程中也没有线程表。相反，在内核中会有用来记录系统中所有线程的线程表。当某个线程希望创建一个新线程或撤销一个已有线程时，它会进行一个系统调用，这个系统调用通过对线程表的更新来完成线程创建或销毁工作。 内核中的线程表持有每个线程的寄存器、状态和其他信息。这些信息和用户空间中的线程信息相同，但是位置却被放在了内核中而不是用户空间中。另外，内核还维护了一张进程表用来跟踪系统状态。 所有能够阻塞的调用都会通过系统调用的方式来实现，当一个线程阻塞时，内核可以进行选择，是运行在同一个进程中的另一个线程（如果有就绪线程的话）还是运行一个另一个进程中的线程。但是在用户实现中，运行时系统始终运行自己的线程，直到内核剥夺它的 CPU 时间片（或者没有可运行的线程存在了）为止。 由于在内核中创建或者销毁线程的开销比较大，所以某些系统会采用可循环利用的方式来回收线程。当某个线程被销毁时，就把它标志为不可运行的状态，但是其内部结构没有受到影响。稍后，在必须创建一个新线程时，就会重新启用旧线程，把它标志为可用状态。 如果某个进程中的线程造成缺页故障后，内核很容易的就能检查出来是否有其他可运行的线程，如果有的话，在等待所需要的页面从磁盘读入时，就选择一个可运行的线程运行。这样做的缺点是系统调用的代价比较大，所以如果线程的操作（创建、终止）比较多，就会带来很大的开销。 混合实现结合用户空间和内核空间的优点，设计人员采用了一种内核级线程的方式，然后将用户级线程与某些或者全部内核线程多路复用起来 在这种模型中，编程人员可以自由控制用户线程和内核线程的数量，具有很大的灵活度。采用这种方法，内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程多路复用。","categories":[{"name":"编程类","slug":"编程类","permalink":"https://dannysunsan.github.io/categories/%E7%BC%96%E7%A8%8B%E7%B1%BB/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://dannysunsan.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"linux","slug":"linux","permalink":"https://dannysunsan.github.io/tags/linux/"},{"name":"windows","slug":"windows","permalink":"https://dannysunsan.github.io/tags/windows/"}]},{"title":"Hello，World!你好，世界！","slug":"hello-world","date":"2014-01-21T15:33:02.000Z","updated":"2021-11-23T06:52:39.911Z","comments":true,"path":"编程类/hello-world/","link":"","permalink":"https://dannysunsan.github.io/%E7%BC%96%E7%A8%8B%E7%B1%BB/hello-world/","excerpt":"","text":"欢迎来到我的博客，在这里我会分享一些学习经历以及一些生活琐事。","categories":[{"name":"编程类","slug":"编程类","permalink":"https://dannysunsan.github.io/categories/%E7%BC%96%E7%A8%8B%E7%B1%BB/"}],"tags":[]}],"categories":[{"name":"编程类","slug":"编程类","permalink":"https://dannysunsan.github.io/categories/%E7%BC%96%E7%A8%8B%E7%B1%BB/"},{"name":"Markdown","slug":"Markdown","permalink":"https://dannysunsan.github.io/categories/Markdown/"},{"name":"hexo","slug":"hexo","permalink":"https://dannysunsan.github.io/categories/hexo/"}],"tags":[{"name":"python","slug":"python","permalink":"https://dannysunsan.github.io/tags/python/"},{"name":"c++","slug":"c","permalink":"https://dannysunsan.github.io/tags/c/"},{"name":"多线程","slug":"多线程","permalink":"https://dannysunsan.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"并发","slug":"并发","permalink":"https://dannysunsan.github.io/tags/%E5%B9%B6%E5%8F%91/"},{"name":"多进程","slug":"多进程","permalink":"https://dannysunsan.github.io/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"},{"name":"IPC","slug":"IPC","permalink":"https://dannysunsan.github.io/tags/IPC/"},{"name":"Markdown","slug":"Markdown","permalink":"https://dannysunsan.github.io/tags/Markdown/"},{"name":"linux","slug":"linux","permalink":"https://dannysunsan.github.io/tags/linux/"},{"name":"windows","slug":"windows","permalink":"https://dannysunsan.github.io/tags/windows/"}]}